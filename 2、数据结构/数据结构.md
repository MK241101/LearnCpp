# 1 基本知识

## 1.1 双指针法

### 1.1.1 元素逆序

### 1.1.2 奇偶数调整问题

### 1.1.3 移动元素问题

### 1.1.4 单链表求倒数第k个节点的值

### 1.1.5 合并两个有序单链表

### 1.1.6 判断单链表是否有环

## 1.1.7 判断两个单链表是否相交，返回相交节点的值

## 1.1.8 删除链表倒数第k个节点

## 1.1.9 旋转链表

# 2 数组

## 2.1基本实现

```cpp
#include<iostream>
using namespace std;

class Array
{
public:
	Array(int cap = 10) :capacity(cap), num(0)
	{
		ptr = new int[cap];
	}
	~Array()
	{
		delete[]ptr;
		ptr = nullptr;
	}

	void push_back(int val){
		if (num == capacity) {
			expand();
		}
		else {
			ptr[num++]=val;
		}
	}
    
	void pop_back() {
		num--;
	}
    
	void insert(int i,int val) {
		if (i<0 || i>num) {
			cout << "插入位置无效" << endl; 
		}
		for (int j=num-1; j >=i; j--) {
			ptr[j+1] = ptr[j];
		}
		ptr[i] = val;
		num++;
	}

	void erase(int i) {
		if (i<0 || i>num) {
			cout << "删除位置无效" << endl;
		}
		for (int j = i; j < num; j++) {
			ptr[j] = ptr[j+1];
		}
		num--;
	}
    
	void find(int val){
	for(int i=0;i<num;i++)
		if (ptr[i] == val) {
			cout << "数组中存在值为" << val << "的元素，下标为" << i << endl;
			return ;
		}
		cout << "数组中不存在值为" << val << "的元素"<<endl;
	}

	void print() {
		for (int i = 0; i < num; i++) {
			cout << "数组中的值为：" << ptr[i]<<endl;
		}
		cout << "-----------------" << endl;
	}
private:
	int num;
	int capacity;
	int* ptr;

private:
	void expand()
	{
		int *p = new int[capacity*2];
		memcpy(p, ptr, num * sizeof(int));
		delete[]ptr;
		ptr = p;
		capacity = capacity * 2;
	}
};

int main()
{
	Array arr(5);
	srand(time(0));
	for (int i = 0; i < 5; i++) {
		arr.push_back(rand()%10);
	}
	arr.print();
	arr.find(3);
	return 0;
}

```

