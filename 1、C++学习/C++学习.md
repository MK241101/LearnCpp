# 1. 基础知识

## 1.1 流操作

strstream类专门用于处理字符串流操作,它允许将字符串当作流来处理,可以方便地进行字符串的读写操作。（C++11 后已被弃用）

fstream用于文件流操作,主要处理文件的输入输出。

iostream是标准的输入输出流类,用于控制台的输入输出操作。

## 1.2 转义字符表示法

- **八进制转义**：`\` + 1-3 个八进制数字（0-7），如 `\112`（对应 'J'）；

- **十六进制转义**：`\x` + 1 个及以上十六进制数字，如 `\x4A`（也对应 'J'）；

- **特殊转义序列**：预定义的固定含义字符，如 `\n`（换行）、`\t`（制表符）等。

合法的转义需要保证最终数值在 `char` 的范围内（通常 0-255）

## 1.3 free()和malloc()

- free()函数只是内存归还给程序的堆空间，由操作系统统一管理，而不能直接释放物理内存
- malloc()函数实际上是向操作系统申请虚拟内存，而不是直接申请物理内存
```cpp
class A
{
public:
    A() { printf("A"); }
    ~A() { printf("~A"); }
    void B() { printf("B"); }
};
int main()
{
    A* a = (A*)malloc(sizeof(A));
    a->B();
    free(a);
    return 0;
}
//此题最后输出B
```

`malloc` 是 C 语言的内存分配函数，仅负责分配一块大小为 `sizeof(A)` 的原始内存，**不会调用类 `A` 的构造函数**。

  **`a->B();`**

调用 `A` 类的成员函数 `B()`。在 C++ 中，**非静态成员函数的调用只依赖于对象的指针（或引用）是否非空，不检查对象是否被正确构造**。

## 1.4 编译和链接

![编译与链接](assets/编译与链接.png)

## 1.5 编译器报错：Segmentation fault

有可能有三种错误：

- 访问空指针
- 数组访问越界
- 使用已释放的内存

## 1.6 左值和右值

- 左值：有内存地址，有名字，值是可以被修改的


- 右值：没内存地址，没名字

```C++
int main()
{
	int a = 10;     // a是左值，10是右值
	int &c = 20;    // 左值引用
	int &&c = 20;   // 右值引用
	c = 30;
    int &&d = c;    // 错误，不能用一个右值引用变量来引用一个左值
	return 0；
}
```

## 1.7 运算符优先级

| 优先级 | 运算符组         | 具体运算符                                                   | 结合性                              | 示例代码                                     |
| ------ | ---------------- | ------------------------------------------------------------ | ----------------------------------- | -------------------------------------------- |
| 1      | 基础成员访问     | `()`（函数调用 / 分组）、`[]`（数组访问）、<br />`->`（指针成员）、`.`（对象成员） | 左结合                              | `func(3)`、`arr[0]`、`p->x`、`obj.y`         |
| 1      | 后缀增减         | `++`（后缀自增）、`--`（后缀自减）                           | 左结合                              | `a++`、`b--`                                 |
| 1      | 类型相关         | `typeid`、`const_cast`/`dynamic_cast`/`reinterpret_cast`/`static_cast` | 左结合                              | `typeid(int)`、`static_cast<int>(3.14)`      |
| 2      | 前缀增减与符号   | `++`（前缀自增）、`--`（前缀自减）、`+`（正号）、`-`（负号） | 右结合                              | `++a`、`-b`、`+3.14`                         |
| 2      | 逻辑非与位运算   | `!`（逻辑非）、`~`（按位取反）                               | 右结合                              | `!flag`、`~0x0F`                             |
| 2      | 指针操作         | `*`（解引用）、`&`（取地址）                                 | 右结合                              | `*p`、`&a`                                   |
| 2      | 内存管理         | `new`、`new[]`（动态分配）、`delete`、`delete[]`（动态释放） | 右结合                              | `int* p = new int`、`delete p`               |
| 2      | 大小计算         | `sizeof`（类型 / 对象大小）、`sizeof...`（参数包大小）       | 右结合                              | `sizeof(int)`、`sizeof(arr)`                 |
| 3      | 成员指针访问     | `->*`（指针访问成员指针）、`.*`（对象访问成员指针）          | 左结合                              | `p->*mem_ptr`、`obj.*mem_ptr`                |
| 4      | 乘法与除法       | `*`（乘法）、`/`（除法）、`%`（取模）                        | 左结合                              | `a * b`、`c / d`、`e % 3`                    |
| 5      | 加法与减法       | `+`（加法）、`-`（减法）                                     | 左结合                              | `x + y`、`m - n`                             |
| 6      | 移位运算         | `<<`（左移）、`>>`（右移）                                   | 左结合                              | `a << 2`（左移 2 位）、`b >> 1`（右移 1 位） |
| 7      | 关系运算（大小） | `<`（小于）、`>`（大于）、`<=`（小于等于）、`>=`（大于等于） | 左结合                              | `a < b`、`x >= y`                            |
| 8      | 关系运算（相等） | `==`（等于）、`!=`（不等于）                                 | 左结合                              | `a == 5`、`x != y`                           |
| 9      | 按位与           | `&`（按位与）                                                | 左结合                              | `a & 0x01`（取最低位）                       |
| 10     | 按位异或         | `^`（按位异或）                                              | 左结合                              | `a ^ b`                                      |
| 11     | 按位或           | ` | `（按位或）                                              | 二进制位逻辑或（对应位有 1 则为 1） |                                              |
| 12     | 逻辑与           | `&&`（逻辑与）                                               | 左结合                              | `a > 0 && b < 10`                            |
| 13     | 逻辑或           | `                                                            |                                     | 左结合                                       |
| 14     | 三目运算符       | `?:`（条件运算符）                                           | 右结合                              | `a > b ? a : b`（取较大值）                  |
| 15     | 赋值运算         | `=`、`+=`、`-=`、`*=`、`/=`、`%=`、`<<=`、`>>=`、`&=`、`^=`、` | =` | 赋值或复合赋值                      | （如`a += b`等价于`a = a + b`）              |
| 16     | throw 表达式     | `throw`（抛出异常）                                          | 右结合                              | `throw std::runtime_error("error")`          |
| 17     | 逗号运算符       | `,`（逗号）                                                  | 左结合                              | `a = 1, b = 2, a + b`（结果为 3）            |

## 1.8 或、与、非、异或（逻辑 / 位运算）总结表

| 运算类型     | 运算符 | 运算名称 | 核心用法                                                     | 操作数要求                                                   | 关键特性                                       |
| ------------ | ------ | -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------------------- |
| **逻辑运算** | &&     | 逻辑与   | 判断两个条件是否**同时成立**，常用于多条件同时满足的判断（如 `if (cond1 && cond2)`） | 操作数需能隐式转换为 `bool` 类型（如 int、bool、指针等）     | 有短路特性（左操作数为假时，右操作数不执行）   |
| **逻辑运算** | \|\|   | 逻辑或   | 判断两个条件是否**至少一个成立**，常用于多条件满足其一的判断（如 `if (cond1cond2)`） | 同逻辑与，操作数需能隐式转换为 `bool` 类型                   | 有短路特性（左操作数为真时，右操作数不执行）   |
| **逻辑运算** | !      | 逻辑非   | 对单个条件的真假性**取反**，常用于否定条件（如 `if (!cond)`） | 同逻辑与，操作数需能隐式转换为 `bool` 类型                   | 单目运算，优先级高于算术运算符，需注意括号搭配 |
| **位运算**   | &      | 位与     | 对两个整数的**每一位逐位运算**，用于保留指定位（如保留特定位、判断奇偶性） | 操作数必须是整数类型（char、short、int、long 等，不可为 bool 或浮点数） | 无短路特性                                     |
| **位运算**   | \|     | 位或     | 对两个整数的**每一位逐位运算**，用于设置指定位（如将某位置为 1） | 同一位与，操作数必须是整数类型                               | 无短路特性，左右操作数均会执行                 |
| **位运算**   | `^`    | 位异或   | 用于翻转指定位、交换两个整数（无需临时变量）    “**同 0 异 1**”。 | 同一位与，操作数必须是整数类型                               | 无短路特性                                     |
| **位运算**   | `~`    | 位非     | 对单个整数的**每一位逐位取反**（0→1，1→0），用于按位翻转数值 | 同一位与，操作数必须是整数类型                               | 单目运算，取反范围包含符号位（依赖补码规则）   |

## 1.9 四种类型转换

| 转换运算符         | 核心作用                                     | 适用场景                                                     | 特点 / 限制                                                  |
| ------------------ | -------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `static_cast`      | 编译时完成类型转换，不进行运行时类型检查     | 1. 基本数据类型间转换（如 `double`→`int`）2. 类层次中基类与派生类的指针 / 引用转换（向上转换安全，向下转换有风险）3. 空指针与目标类型空指针的转换、任意类型与 `void` 类型的转换 | 1. 无法移除指针 / 引用的 `const`/`volatile` 属性2. 依赖开发者保证转换安全性，编译不检查实际类型匹配 |
| `dynamic_cast`     | 运行时进行类型转换，支持安全的向下转换       | 1. 多态类（含虚函数）的指针 / 引用转换，尤其是基类→派生类的 “向下转换”2. 类层次中的交叉转换，支持向上转换和向下转换 | 1. 要求基类必须包含至少一个虚函数（支持运行时类型识别 RTTI）2. 转换失败时：指针返回 `nullptr`，引用抛出 `std::bad_cast` 异常 |
| `const_cast`       | 移除指针或引用的 `const`/`volatile` 属性     | 1. 通过指针 / 引用间接修改 “被 `const` 修饰的对象”（需确保原对象本身非 `const` 定义，否则行为未定义） | 1. 仅能操作指针或引用，不能直接修改 `const` 修饰的内置变量2. 不改变对象本身的 `const` 性，仅改变指针 / 引用对其的访问权限 |
| `reinterpret_cast` | 重新解释数据的二进制表示，仅改变类型解读方式 | 1. 不同类型指针 / 引用之间的转换（如 `int*`→`char*`）2. 指针与整数类型（如 `uintptr_t`）之间的转换3. 函数指针之间的转换 | 1. 不进行任何类型检查，几乎允许所有类型转换2. 不改变底层比特位，仅修改类型标签3. 结果依赖平台（如指针大小、字节序），可移植性差4. 风险极高，易导致未定义行为（如访问非法内存） |

## 1.10 数组名和数组

**多数情况下数组名会隐式转换为 “指向第一个元素的指针”，但在少数特殊场景中会保留 “整个数组” 的语义**。以下是具体总结：

### （1）数组名表示 “指向第一个元素的指针”（默认转换）

- **参与指针运算（如 `+`、`-`）**

```C++
int arr[5] = {1,2,3,4,5}; 
arr + 1：         //arr 转换为 int* 类型（指向 arr[0]），+1 后指向 arr[1]（步长为 sizeof(int)）
*(arr + 2);       //等价于 arr[2]，结果为 3。
```

- **作为函数参数传递**

​		C 语言中，数组作为参数传递时，会被自动转换为指向首元素的指针（“数组退化”）。

```C++
void func(int arr[]) {  // 等价于 void func(int* arr)
    // 此处 arr 是 int* 类型，而非数组
}
int main() {
    int arr[5] = {1,2,3,4,5};
    func(arr);  // arr 转换为指向 arr[0] 的 int*
}
```

- **赋值给同类型指针**

```C++
int arr[5];
int* p = arr;  // 正确：arr 转换为 int*，指向 arr[0]
```

- **作为解引用运算符 `*` 的操作数**

例：`*arr` 等价于 `arr[0]`（`arr` 转换为指向 `arr[0]` 的指针，解引用后得到首元素）。

### （2）数组名表示 “整个数组的地址”

- **作为 `sizeof` 运算符的操作数**

​		`sizeof(数组名)` 计算的是**整个数组的总字节数**（而非指针的大小），此时数组名表示整个数组。

```C++
int arr[5];
printf("%zu", sizeof(arr));  // 结果为 5 * sizeof(int)（通常是 20 字节）
printf("%zu", sizeof(arr + 0));  // arr+0 触发转换，结果为 sizeof(int*)（通常是 8 字节）
```

- **作为 `&`（取地址运算符）的操作数**

​		`&数组名` 得到的是 “整个数组的地址”，类型为 “指向数组的指针”（而非指向首元素的指针）。

```C++
int arr[5] = {1,2,3,4,5};
int (*p)[5] = &arr;  // 正确：&arr 类型是 int (*)[5]（指向“5个int的数组”的指针）
```

**注意：**`&arr`和`arr`的数值地址相同（都指向数组起始位置），但类型不同：

​			`arr` 是 `int*` 类型，`+1` 移动 `sizeof(int)` 字节（指向 `arr[1]`）；

​			`&arr` 是 `int (*)[5]` 类型，`+1` 移动 `5*sizeof(int)` 字节（指向数组末尾的下一个位置）。

- **作为字符串字面量初始化另一个数组**

当用字符串字面量（本质是字符数组）初始化另一个字符数组时，字符串字面量保留数组语义，用于完整初始化目标数组。

```C++
char str[] = "hello";  // "hello" 是字符数组（含 '\0'），此处表示整个数组，用于初始化 str
```

| 场景                       | 数组名的含义               | 类型示例（以 `int arr[5]` 为例）     |
| -------------------------- | -------------------------- | ------------------------------------ |
| 多数表达式（运算、传参等） | 指向首元素的指针           | `int*`（指向 `arr[0]`）              |
| `sizeof(数组名)`           | 整个数组（计算总大小）     | 数组类型 `int[5]`                    |
| `&数组名`                  | 整个数组的地址             | `int (*)[5]`（指向整个数组）         |
| 字符串字面量初始化数组     | 整个字符串数组（完整赋值） | 字符数组类型 `char[6]`（如 "hello"） |

```C++
int arr[5]={1,2,3,4,5};

&arr;  				//类型为 int (*)[5]，表示整个数组的地址
*&arr;  			//表示数组首元素arr[0]的地址
**&arr;  			//*&arr（已转换为 int*）再解引用，得到 arr[0] 的值,1
&arr+1;  			//表示从arr[5]开始的下一个数组地址
arr;   				//表示数组首元素arr[0]的地址
*arr;  				//表示数组首元素arr[0]的值
arr+1;  			//指向 arr[1]（值为 2 的地址）
&arr[0];  			//指向 arr[0]（值为 1 的地址）
*(arr + 1);   		//等价于arr[1]，2
&arr[0] + 1; 		// 指向 arr[1] 的地址
sizeof(arr); 		//整个数组的总字节数（通常 20 字节）
sizeof(&arr);  		//通常 4 字节（32 位系统）
sizeof(arr + 0);    //通常 4 字节（32 位系统）
```

## 1.11 程序的内存布局

**32 位系统** 下的进程虚拟地址空间布局

<img src="assets/程序在内存中的布局.png" alt="程序在内存中的布局" style="zoom:50%;" />

## 1.12 数值类型取值范围

| 类型类别                              | 具体类型                      | 字节数                 | 取值范围                                                 |
| ------------------------------------- | ----------------------------- | ---------------------- | -------------------------------------------------------- |
| **固定宽度无符号整数**（`<cstdint>`） | `uint8_t`                     | 1                      | `0` ~ `2⁸ - 1`（即 `0` ~ `255`）                         |
|                                       | `uint16_t`                    | 2                      | `0` ~ `2¹⁶ - 1`（即 `0` ~ `65535`）                      |
|                                       | `uint32_t`                    | 4                      | `0` ~ `2³² - 1`（即 `0` ~ `4,294,967,295`）              |
|                                       | `uint64_t`                    | 8                      | `0` ~ `2⁶⁴ - 1`                                          |
| **固定宽度有符号整数**（`<cstdint>`） | `int8_t`                      | 1                      | `-2⁷` ~ `2⁷ - 1`（即 `-128` ~ `127`）                    |
|                                       | `int16_t`                     | 2                      | `-2¹⁵` ~ `2¹⁵ - 1`（即 `-32,768` ~ `32,767`）            |
|                                       | `int32_t`                     | 4                      | `-2³¹` ~ `2³¹ - 1`                                       |
|                                       | `int64_t`                     | 8                      | `-2⁶³` ~ `2⁶³ - 1`                                       |
| **基础无符号整数**                    | `unsigned char`               | 1                      | `0` ~ `255`（与 `uint8_t` 等价）                         |
|                                       | `unsigned short`              | 2                      | `0` ~ `65535`（与 `uint16_t` 等价）                      |
|                                       | `unsigned int`                | 4                      | `0` ~ `4,294,967,295`（多数环境与 `uint32_t` 等价）      |
|                                       | `unsigned long`               | 4（32 位）/ 8（64 位） |                                                          |
|                                       | `unsigned long long`          | 8                      | `0` ~ `18,446,744,073,709,551,615`（与 `uint64_t` 等价） |
| **基础有符号整数**                    | `signed char`                 | 1                      | `-128` ~ `127`（与 `int8_t` 等价）                       |
|                                       | `short` / `short int`         | 2                      | `-32,768` ~ `32,767`（与 `int16_t` 等价）                |
|                                       | `int`                         | 4                      | `-2³¹` ~ `2³¹ - 1`                                       |
|                                       | `long` / `long int`           | 4（32 位）/ 8（64 位） |                                                          |
|                                       | `long long` / `long long int` | 8                      |                                                          |
| **浮点类型**                          | `float`                       | 4                      | 约 `3.4×10⁻³⁸` ~ `3.4×10³⁸`（有效数字约 7 位）           |
|                                       | `double`                      | 8                      | 约 `1.7×10⁻³⁰⁸` ~ `1.7×10³⁰⁸`（有效数字约 15~17 位）     |
|                                       | `long double`                 | 8（或 16，依平台）     | 通常与 `double` 精度一致；                               |

## 1.13 strcpy用法

**（1）函数原型**

```c
char* strcpy(char* dest, const char* src);
```

- 参数
  - `dest`：目标缓冲区（char 类型指针），用于存储复制后的字符串。
  - `src`：源字符串（const char 类型指针），需以空字符 `'\0'` 结尾（C 风格字符串的标志）。
- **返回值**：返回目标缓冲区 `dest` 的指针（通常很少使用该返回值）。

**（2）工作原理**

`strcpy` 会从 `src` 的第一个字符开始，逐个复制到 `dest` 中，**直到遇到 `src` 中的 `'\0'`**（包括 `'\0'` 也会被复制到 `dest` 中）。

例如，若 `src` 是 `"abc"`（实际存储为 `'a','b','c','\0'`），则 `strcpy` 会将这 4 个字符完整复制到 `dest`。

## 1.14 register关键字

​	核心作用是**建议编译器将变量存储在 CPU 寄存器中**，以减少变量的访问时间（寄存器访问速度远快于内存），从而提升程序执行效率。它本质是对编译器的 “优化建议”，而非强制命令。

​	`register` 关键字的核心使用限制之一就是：**只能修饰局部自动变量（即函数内部声明的、无 `static` 修饰的变量）**，而**不能用于类的数据成员**，原因是：类的数据成员属于类的实例（对象）的一部分，其存储位置在对象的内存空间中（堆或栈上），具有明确的内存地址，供对象访问和修改。而 `register` 关键字的本质是 “建议编译器将变量存储在 CPU 寄存器中”，**寄存器没有内存地址**，

```cpp
#include <stdio.h>

int main() {
    // 建议将循环计数器 i 存入寄存器（频繁自增和判断）
    register int i;
    long long sum = 0;
    for (i = 0; i < 1000000000; i++) {
        sum += i;
    }
    printf("sum = %lld\n", sum);
    return 0;
}
```

- C++11 后，`register` 的语义被弱化，仅保留 “提示编译器优化” 的作用，且不能修饰函数参数。
- C++17 正式将 `register` 列为**弃用关键字**（deprecated），未来可能被移除，因为编译器优化已完全替代其功能。

## 1.15 memcpy的用法

在 C++ 中，`memcpy` 是一个用于内存块复制的标准库函数，定义在 `<cstring>` 头文件中。它可以将指定大小的内存块从源地址复制到目标地址，是处理内存级数据复制的常用工具。

**`memcpy` 的函数原型**

```cpp
void* memcpy(void* destination, const void* source, size_t num);
```

- **参数说明**：
  - `destination`：指向目标内存块的指针（复制的目的地）
  - `source`：指向源内存块的指针（复制的来源）
  - `num`：要复制的字节数（`size_t` 类型，通常是无符号整数）
- **返回值**：返回指向目标内存块 `destination` 的指针

**基本用法**

`memcpy` 的核心功能是按字节复制内存，使用时需要确保：

1. 目标内存块有足够的空间容纳 `num` 字节的数据
2. 源内存块和目标内存块的大小至少为 `num` 字节
3. 两个内存块不应重叠（如果需要处理重叠内存，应使用 `memmove`）

```cpp
#include <iostream>
#include <cstring> // 包含 memcpy 函数

int main() {
    // 示例 1：复制字符数组
    char source[] = "Hello, memcpy!";
    char destination[20]; // 确保目标数组足够大
    
    // 复制整个源字符串（包括终止符 '\0'）
    memcpy(destination, source, strlen(source) + 1);
    std::cout << "复制的字符串: " << destination << std::endl;
    
    // 示例 2：复制整数数组
    int src[] = {1, 2, 3, 4, 5};
    int dest[5];
    
    // 计算需要复制的总字节数：元素个数 × 每个元素的大小
    size_t bytes = sizeof(src);
    memcpy(dest, src, bytes);
    
    std::cout << "复制的整数: ";
    for (int i = 0; i < 5; ++i) {
        std::cout << dest[i] << " ";
    }
    std::cout << std::endl;
    
    return 0;
}
```

**注意事项**

1. **内存重叠问题**：如果源内存和目标内存有重叠，`memcpy` 的行为是未定义的，此时应使用 `memmove` 替代。
2. **类型无关性**：`memcpy` 以字节为单位复制，不关心数据类型，因此可以用于复制任何类型的数据（包括自定义结构体）。
3. **字符串处理**：虽然可以用 `memcpy` 复制字符串，但对于以 `\0` 结尾的字符串，`strcpy` 或 `strncpy` 可能更合适，因为它们会自动处理终止符。
4. **安全问题**：使用 `memcpy` 时必须确保目标缓冲区足够大，否则会导致缓冲区溢出，这是常见的安全漏洞来源。

**与 strcpy 的区别**

- `memcpy` 可以复制任意类型的内存块，需要显式指定复制的字节数
- `strcpy` 专门用于复制字符串，会在遇到 `\0` 时自动停止，不需要指定长度

总之，`memcpy` 是一个高效的内存复制工具，适用于需要精确控制复制字节数的场景，但使用时必须格外注意内存边界和重叠问题。

## 1.16 判断奇偶数

```cpp
if((*p & 0x1)==0);  //偶数
if((*p & 0x1)==1)； //奇数
```

## 1.17 大端和小端

多字节数据由 “高位字节” 和 “低位字节” 组成。例如，十六进制数 `0x1234` 中：

- 高位字节：`0x12`（权重更高，对应 “千位、百位” 的概念）；
- 低位字节：`0x34`（权重更低，对应 “十位、个位” 的概念）。

**大端字节序：**高位字节存储在低地址，低位字节存储在高地址。类比 “人类书写数字的习惯”：我们写 `1234` 时，先写高位的 `12`，再写低位的 `34`，大端的存储顺序与之一致。

**小端字节序：**低位字节存储在低地址，高位字节存储在高地址。与人类书写习惯相反，更贴近计算机底层的 “字节级操作” 逻辑。

```cpp
//比如十六进制数  0x1234
//大端：0001001000110100    直接按照上面的顺序写就是大端
//小端：0011010000010010    先写34 再写12  就是小端
```

## 1.18  explicit用法

| 应用场景                       | 作用                                                         | 适用 C++ 版本 | 效果描述                                                     |
| ------------------------------ | ------------------------------------------------------------ | ------------- | ------------------------------------------------------------ |
| 修饰单参数构造函数             | 禁止通过 “参数类型” 隐式转换为类对象                         | 所有版本      | 必须显式调用构造函数创建对象，无法直接用参数值隐式初始化类对象 |
| 修饰类型转换运算符             | 禁止从类类型隐式转换为目标类型（如`operator bool()`、`operator int()`） | C++11 及以后  | 不能直接将类对象隐式转为目标类型，需通过`static_cast`等显式转换方式 |
| 修饰类模板推导指引             | 禁止从初始化表达式隐式推导模板类类型                         | C++17 及以后  | 无法通过表达式隐式推导出模板类的具体类型，需显式构造或直接指定模板参数 |
| 条件显式（`explicit(表达式)`） | 根据常量表达式的值（`true`/`false`）动态决定是否禁止隐式转换 | C++20 及以后  | 表达式为`true`时禁止隐式转换，为`false`时允许，灵活控制转换的显式性 |

`explicit` 的本质是**阻止 “悄悄发生的隐式类型转换”**，强制开发者通过 “显式构造 / 转换” 来表达意图，从而避免因意外转换导致的逻辑错误，让代码行为更可控、更安全。

## 1.19 静态成员

```cpp
#include <iostream>
using namespace std;
class cla {
    static int n;
 
  public:
    cla() { n++; }
    ~cla() { n--; }
    static int get_n() { return n; }
};
int cla::n = 0;
int main() {
    cla *p = new cla;
    delete p;
    cout << "n=" << cla::get_n() << endl;
    return 0;
}
// 输出 0
```

此题引出的问题是：**为什么都已经析构了还可以调用静态函数呢？   是因为静态函数和静态变量 存放在.bss段中吗？**

**（1）静态成员不属于 “对象”，而属于 “类” 本身**

​	C++ 中，类的非静态成员（如普通成员变量、非静态成员函数）是**依附于对象存在的**：每个对象都有独立的非静态成员变量副本，调用非静态成员函数时需要通过对象（或指针 / 引用），本质是传递了 `this` 指针指向具体对象。

但**静态成员（静态变量、静态函数）属于类本身**，而非某个具体对象：

- 它们在程序启动时（类首次被使用前）就已初始化，生命周期贯穿整个程序运行过程，直到程序结束才销毁。
- 调用静态函数时，不需要依赖任何对象（无需 `this` 指针），直接通过类名（如 `cla::get_n()`）即可调用，与对象是否存在无关。

**（2）为什么对象析构后仍能调用静态函数？**

在你的代码中：

- `delete p;` 销毁了通过 `new` 创建的 `cla` 对象，此时会调用该对象的析构函数（`n--`），但这仅影响对象本身的生命周期（对象被销毁）。
- 静态函数 `get_n()` 和静态变量 `n` 属于 `cla` 类，它们的生命周期与程序绑定，并不会因为某个对象的析构而消失。因此，即使所有 `cla` 对象都被销毁，依然可以通过类名调用静态函数访问静态变量。

**（3）关于存储位置：.bss 段是实现细节，而非核心原因**

静态成员的存储位置确实与普通成员不同：

- 非静态成员变量：存储在对象的内存空间中（栈或堆，取决于对象创建方式）。
- 静态成员变量：如果是未初始化的全局静态变量或类静态变量，通常存放在 **.bss 段**（未初始化数据段）；如果是初始化的，则存放在 **.data 段**（已初始化数据段）。
- 静态成员函数：与普通函数一样，存放在 **.text 段**（代码段），因为它们是可执行的机器指令。

## 1.20 strlen()用法

计算**以`'\0'`结尾的字符串的有效长度**（不含`'\0'`）。与`sizeof`区别：

- `strlen`：函数，算有效字符数（不含`'\0'`）。
- `sizeof`：运算符，算内存总字节数（含`'\0'`）。

```cpp
char s[] = "abc";
printf("strlen: %zu, sizeof: %zu", strlen(s), sizeof(s)); 
// 输出：3（有效字符）、4（含'\0'的总字节）
```

## 1.21 strcat()用法

`strcat()`用于将**源字符串**的内容追加到**目标字符串**的末尾，拼接后形成一个新的字符串。

```cpp
#include <cstring>  // 必须包含的头文件

char* strcat(char* destination, const char* source);
```

- 参数：
  - `destination`：目标字符串（已存在的字符串，需有足够空间容纳拼接后的结果）。
  - `source`：源字符串（被追加的字符串，`const` 表示其内容不会被修改）。
- **返回值**：返回拼接后的目标字符串 `destination` 的首地址（方便链式调用）。
- 工作原理

1. 从 `destination` 的结尾（即第一个 `'\0'` 处）开始，逐个复制 `source` 的字符（包括 `source` 的 `'\0'`）。
2. 最终 `destination` 会包含原 `destination` + 原 `source` 的内容，且仅以一个 `'\0'` 结尾。

#### 四、使用示例

```cpp
#include <iostream>
#include <cstring>
using namespace std;

int main() {
    char dest[20] = "Hello";  // 目标字符串（需预留足够空间）
    const char* src = " World";  // 源字符串
    
    // 拼接：将src追加到dest末尾
    strcat(dest, src);
    
    cout << "拼接后：" << dest << endl;  // 输出：Hello World
    return 0;
}
```

- **注意事项（重点！）**

​	（1）**目标字符串必须有足够空间**

  - 若 `dest` 的内存空间不足以容纳拼接后的结果（原 `dest` 长度 + `src` 长度 + 1 个 `'\0'`），会导致**缓冲区溢出**（未定义行为，可能崩溃或数据错乱）。
  - 示例：`char dest[6] = "Hello";` 只能容纳 6 个字符（含 `'\0'`），若拼接 `" World"`（6 个字符 + `'\0'`），则会溢出。

​	（2）**目标字符串必须可修改**

  - `dest` 必须是**字符数组**（如 `char dest[20];`），不能是字符串常量（如 `char* dest = "Hello";`，常量不可修改）。

​	（3）**源字符串必须以 `'\0'` 结尾**

  - `strcat()` 通过 `'\0'` 判断 `source` 的结束位置，若 `source` 没有 `'\0'`，会导致复制越界。

# 2. C++基础部分

## 2.1 C++中的struct

​		在C++中，struct不再是”简单的数据结构“，而是一个完善的、支持面向对象特性的类，与class唯一的区别就是，默认访问权限都为public，而class的变量与方法默认为private

​		在 C++ 中，结构体（或类）的成员若为**自身的对象类型**，会因 “无限递归、大小无法确定” 而不允许；但如果是**自身的指针类型**或**引用类型**，则是允许的（指针大小固定，引用无无限递归问题）。此外，**相互引用**时，可通过 “前向声明”+“指针 / 引用” 的方式实现。

```C++
struct A{A a;};   // 不允许的
struct A{A* a;};  // 可以
struct A{A& a;};  // 可以
struct B; struct A{B& b;}; struct B{A& a;};  //可以相互引用
```



## 2.2 引用

- 引用的本质就是起别名，例如  张三→三哥   都指向的同一个人    


- 引用：int&，声明时 & 紧贴类型  


- 取地址：&var，&在变量前面


- &&：右值引用。右值引用的主要设计目的就是为了支持移动语义。（我没搞懂这个的作用）

  - int &&c = 20；专门用来引用右值类型，指令上，可以自动产生临时量，然后直接引用临时量c=20;
  - 右值引用变量本身是一个左值，只能用左值引用来引用它
  - 不能用一个右值引用变量来引用一个左值
  
  ```C++
  int main() {
      int original = 42;  // 原始变量（本尊）
      
      // 1. 引用（起别名）：声明时 & 紧贴类型
      int& alias = original;  // alias 是 original 的别名（张三→三哥）
      
      // 2. 取地址：& 在变量前面
      int* pointer = &original;  // 获取 original 的内存地址
      
      cout << "原始值: " << original << endl;  // 42
      cout << "别名值: " << alias << endl;     // 42
      cout << "指针值: " << *pointer << endl;  // 42
      
      // 通过别名修改
      alias = 100;
      cout << "\n修改后原始值: " << original << endl;  // 100
      
      // 通过指针修改
      *pointer = 200;
      cout << "再次修改后原始值: " << original << endl;  // 200
      
      // 验证本质
      cout << "\n原始地址: " << &original << endl;
      cout << "别名地址: " << &alias << endl;   // 与原始地址相同
      cout << "指针地址: " << pointer << endl;  // 与原始地址相同
      
      return 0;
  }
  ```

### 2.2.1 引用和指针的区别

- 引用必须初始化，指针可以不初始化

- 引用一旦初始化就不能再引用其他对象，而指针可以重新指向其他地址

- 引用只有一级引用，没有多级引用；指针可以有一级指针，也可以有多级指针

- 从汇编指令来看，定义引用变量和指针变量，汇编指令是一模一样的；通过引用修改变量的值和通过指针修改变量的值，汇编指令也是一模一样的

### 2.2.2 父类和子类的引用

```C++
#include <iostream>
using namespace std;
class shape 
{public:  
        virtual int area()=0;
};  

class rectangle:public shape 
{public: 
        int a, b;  
        void setLength (int x, int y) {a=x;b=y;} 
        int area() {return a*b;} 
};

rectangle r; 

shape *s1=&r;   // 父类指针指向子类对象
shape &s2=r;    // 父类引用绑定到子类对象上
```

| 特性               | `shape *s1 = &r;`（基类指针）                         | `shape &s2 = r;`（基类引用）                          |
| ------------------ | ----------------------------------------------------- | ----------------------------------------------------- |
| **本质**           | 定义一个指针变量 `s1`，存储派生类对象 `r` 的地址      | 定义一个引用 `s2`，作为派生类对象 `r` 的 “别名”       |
| **是否创建新对象** | 指针 `s1` 是独立变量（占内存，如 4/8 字节），存储地址 | 引用 `s2` 不创建新对象，仅绑定到 `r`，无额外内存开销  |
| **初始化要求**     | 可先定义再赋值（如 `shape *s1; s1 = &r;`）            | 必须在定义时初始化（`shape &s2; s2 = r;` 是错误的）   |
| **是否可改变指向** | 可重新指向其他对象（如 `s1 = &another_rect;`）        | 一旦绑定，无法再绑定到其他对象（引用的指向是 “常量”） |
| **是否可为空**     | 可赋值为 `nullptr`（如 `s1 = nullptr;`）              | 不存在 “空引用”，必须绑定到有效对象                   |
| **访问成员方式**   | 使用 `->` 访问成员（如 `s1->area();`）                | 使用 `.` 访问成员（如 `s2.area();`）                  |

**总结：**

- 两者的**核心功能相似**（都能通过基类类型操作派生类对象，实现多态），但**本质和使用规则完全不同**。
- 指针更灵活（可重指向、可为空），但需手动管理地址；引用更安全（无空引用、不可变），但初始化后无法修改绑定。

### 2.2.3 右值引用

```C++
int &&d=20;
MyString &&e=MyString("aaa");
```

**右值引用的两大核心用途**

**（1）实现 “移动语义”：避免深拷贝，提升性能**

​		传统的**拷贝语义**（拷贝构造函数、拷贝赋值运算符）会对对象的资源（如堆内存、文件句柄）进行 “深拷贝”，开销大；而**移动语义**通过右值引用，直接 “转移” 右值对象的资源（而非拷贝），大幅减少开销。

- 移动构造函数

- 移动赋值运算符    （详情见3.15 对象优化的规则）

**（2）实现 “完美转发”：保留参数的左右值属性**

```C++
// 模板参数 T&& 是“万能引用”（可接收左值或右值）
template <typename T>
void forwardFunc(T&& arg) {
  // std::forward<T>(arg)：保留 arg 的原始左右值属性
  process(std::forward<T>(arg));  
}

// 测试：分别传递左值和右值
void process(int& arg) { cout << "处理左值\n"; }   // 左值版本
void process(int&& arg) { cout << "处理右值\n"; }  // 右值版本

int main() {
  int a = 10;
  forwardFunc(a);         // 传递左值，调用 process(int&)
  forwardFunc(20);        // 传递右值，调用 process(int&&)
  forwardFunc(std::move(a));  // 传递将亡值，调用 process(int&&)
  return 0;
}
```



## 2.3 友元函数

在 C++ 中，友元函数是一种特殊的函数，它可以访问类的**私有成员和保护成员**，就像类的成员函数一样，但友元函数本身**不是类的成员函数**。

友元函数主要用于以下场景：

- 当需要在类外部操作类的私有成员，且这种操作逻辑更适合用非成员函数实现时（例如某些运算符重载，如 `+` 用于两个不同类对象或类对象与基本类型的运算）。
- 实现跨类的操作，需要同时访问多个类的私有成员时。

在不破坏类封装性的前提下（仅授权特定函数访问），允许外部函数灵活操作类的私有成员，特别适合运算符重载等场景。

```C++
class Complex {
private:
    double real;   // 实部（私有成员）
    double imag;   // 虚部（私有成员）
public:
    Complex(double r = 0, double i = 0) : real(r), imag(i) {}              // 构造函数：初始化real和imag
    
    friend Complex operator+(const Complex& c1, const Complex& c2);        // 声明友元函数：允许operator+访问私有成员
    
    void display() {                                       // 成员函数：打印复数
        cout << real << " + " << imag << "i" << endl;
    }
};

Complex operator+(const Complex& c1, const Complex& c2) {       // 友元函数定义：实现两个复数相加
    Complex res;  // 临时对象：存储相加结果
    res.real = c1.real + c2.real;  // 直接访问c1、c2的私有成员real
    res.imag = c1.imag + c2.imag;  // 直接访问c1、c2的私有成员imag
    return res;   // 返回结果对象
}

int main() {
    Complex c1(1, 2), c2(3, 4);  // 创建两个复数对象
    Complex c3 = c1 + c2;        // 调用友元函数实现加法
    c3.display();                // 输出结果：4 + 6i
    return 0;
}
```

以下运算符**只能通过类的成员函数**重载，不能通过友元函数重载（因为它们与类的 “成员访问”“状态修改” 强相关）：

- 赋值运算符 `=`；
- 下标运算符 `[]`；
- 函数调用运算符 `()`；
- 指向成员的指针运算符 `->` 等。

## 2.4 形参默认值

形参默认值是 C++ 中简化函数调用的实用特性，核心要点：

- **从右向左指定默认值**，不能跳过前面的参数；

  ```C++
  void func(int a, int b = 2, int c = 3) {}    // 从右向左依次指定默认值
  void func(int a = 1, int b) {}               // 错误：b左侧的a没有默认值，却给b设了默认值
  ```

- **同一个形参只能给一次默认值**；

  ```C++
  void printAdd(int a, int b = 10);  // 函数声明：为b指定默认值
  void printAdd(int a, int b = 20)   // 函数定义：如果再次给b指定默认值，会编译错误
      
  void printAdd(int a, int b = 10);  
  void printAdd(int a = 5, int b)    // 正确，两个变量只给了一次默认值
  ```

## 2.5 inline内联函数

- inline内联函数，在**编译过程**中，**没有函数调用的开销**，直接在函数的调用点将函数体展开
- inline内联函数不再生成相应的函数符号
- inline只是建议编译器把这个函数处理成内联函数，并不是所有的inline都会被处理为内联函数（比如递归函数，递归次数需要在运行的时候确定）
- 类体内实现的方法会被自动处理为内联函数
- 内联函数与普通函数的**调用方式完全相同**（直接通过函数名 + 参数列表调用）。

内联函数的核心适用原则是：**“短小精悍且高频调用”**。它通过牺牲代码体积（适度范围内）换取调用效率，适合那些逻辑简单、被频繁执行的小函数。需要注意的是，`inline`只是对编译器的 “建议”，最终是否内联由编译器决定（复杂函数会被自动忽略）

## 2.6 const的用法

### 2.6.1 C和C++中const的区别

- **C**中的const修饰的变量**可以不初始化**，叫做**常变量**
- **C++**中的const修饰的变量**必须初始化**，叫做**常量**
- C++中，所有出现const常量的地方都被常量初始化替换了（相当于变成了立即数，在编译的时候就已经替换了）

### 2.6.2 const修饰的变量和普通变量的区别

- 编译方式不同：const修饰的变量在编译的时候直接替换，也就是变量替换为立即数

- 不能作为左值（初始化完成后，值不能被修改）

### 2.6.3 const修饰的变量经常出现的错误

- 常量不能再作为左值（不能直接修改常量的值）

- 不能把常量的地址泄露给普通的指针或普通引用变量（可以间接修改常量的值）

### 2.6.4 总结const和指针的类型转换公式

```c++
int* p   <===    const int* q      错误
const int* p   <===    int* q     正确   p指向q，但不能通过p修改q的值
    
int**  <===   const int**      错误
const int**   <===  int**      错误  二级指针必须两边都要加const才正确
 
int**  <===   int*const*       错误
int*const*  <===    int**      可以  蜕化为一级指针
```

**注意：const右边如果没有指针*，考虑数据类型的时候忽略const**

### 2.6.5 `const char * const * p;` 的层级关系

这个声明包含三级结构（从右到左）：

- p作为二级指针，存放的是一级指针的地址，由于p没有直接被const修改，p的指向可以改变
- `const *p`，`*p`是一级指针的地址，用const修饰，那么说明一级指针的地址不可修改
- `const **p`，`**p`是一级指针的指向的内容，用const修饰，那么说明一级指针的指向的内容不可修改（分析的时候去掉char）

### 2.6.6 const修饰成员函数

在 C++ 中，`const`修饰成员函数核心是**限制函数对对象状态的修改**

**（1）核心作用：保证 “只读” 行为**

const 成员函数的核心语义是：**不会修改对象的非静态成员变量**，也不会调用非 const 成员函数（避免间接修改对象）。

这一特性使得：

- **const 对象**只能调用 const 成员函数（防止修改 const 对象的状态）；
- **非 const 对象**可以调用 const 和非 const 成员函数（灵活性更高）。

**（2）使用规则与限制**

- **不能修改非静态成员变量**

- 不能调用非 const 成员函数
- 可以访问成员变量，但不能修改
- 静态成员变量不受限制
- 例外情况：`mutable`关键字

```C++
#include <iostream>

class MyClass {
private:
    int m_value = 10;                  // 非静态成员变量
    static int s_count;                // 静态成员变量
    mutable int m_cache = 0;           // mutable成员变量（例外情况）

public:
    // const成员函数：展示各种规则
    void print() const {
        // 1. 可以访问成员变量，但不能修改非静态成员变量
        std::cout << "访问m_value: " << m_value << std::endl;  // 合法
        // m_value = 20;  // 错误：不能修改非静态成员变量

        // 2. 不能调用非const成员函数
        // modify();  // 错误：const函数不能调用非const成员函数

        // 3. 静态成员变量不受限制（可修改）
        s_count++;  // 合法：静态成员变量不受const限制
        std::cout << "修改后s_count: " << s_count << std::endl;

        // 4. mutable关键字例外（可修改）
        m_cache = 100;  // 合法：mutable成员可在const函数中修改
        std::cout << "修改后m_cache: " << m_cache << std::endl;
    }

    // 非const成员函数
    void modify() {
        m_value = 20;  // 合法：非const函数可修改成员变量
    }
};

// 初始化静态成员变量
int MyClass::s_count = 0;

int main() {
    const MyClass obj1;  // const对象
    MyClass obj2;        // 非const对象

    // 5. const对象只能调用const成员函数
    obj1.print();        // 合法：const对象调用const函数
    // obj1.modify();    // 错误：const对象不能调用非const函数

    // 6. 非const对象可以调用const和非const成员函数
    obj2.print();        // 合法：非const对象调用const函数
    obj2.modify();       // 合法：非const对象调用非const函数

    return 0;
}
```





## 2.7 volatile

volatile是一个类型修饰符，用于告知编译器：

​	被修饰的变量的值可能被程序之外的因素（如硬件、中断、其他线程）意外修改，因此编译器不能对该变量的访问进行优化。必须每次都从内存中读取新值，而不能使用寄存器缓存的值。

## 2.8 指针数组和数组指针

### （1）指针数组  `P* a[3]`

- **本质**：一个**数组**，数组名为 `a`，包含 3 个元素。
- **元素类型**：每个元素都是 `P*`（指向类 `P` 的指针）。
- 解析逻辑：`[]` 运算符优先级高于 `*`，因此 `a` 先与 `[3]` 结合，形成数组，再被 `*` 修饰，表示数组元素是指针。

```C++
class P {};
P p1, p2, p3;

// 指针数组：数组a的3个元素都是指向P的指针
P* a[3] = {&p1, &p2, &p3}; 
```

### （2）数组指针  `P(*a)[3]`

- **本质**：一个**指针**，指针名为 `a`。
- **指向的类型**：该指针指向一个**数组**，数组包含 3 个元素，每个元素的类型是 `P`（类 `P` 的对象）。
- 解析逻辑：括号 `()` 改变优先级，`*` 先与 `a` 结合，形成指针，再与 `[3]` 结合，表示指针指向的是一个含 3 个 `P` 元素的数组。

`()`和 [] `优先级相同，因左结合性，先处理左边的`()`，再处理右边的`[]。

```C++
class P {};
P arr[3]; // 一个包含3个P对象的数组

// 数组指针：a是指针，指向包含3个P元素的数组
P(*a)[3] = &arr; 
```

## 2.9 深拷贝与浅拷贝

深拷贝和浅拷贝的核心区别在于**是否复制 “指针 / 引用指向的底层资源”**，主要发生在：

- **对象的拷贝构造和赋值操作；**   特别要注意类的成员变量里面包含指针，这种情况下拷贝构造和赋值操作会出现浅拷贝的问题，释放指针会出现二次释放的问题
- **函数参数 / 返回值按值传递对象；**
- **指针、动态数组等复合类型的复制。**

当复制的对象 / 变量包含**动态分配的资源**（堆内存、文件句柄等）时，必须使用深拷贝；若仅包含基本类型（`int`、`float`等），浅拷贝足够且安全。

出现浅拷贝问题的时候，一定要自定义拷贝构造函数，赋值重载函数

### (1）针对“包含指针/引用的复合类型变量”

当变量是指针、数组、结构体（含指针成员）等复合类型时，拷贝可能涉及“浅”或“深”的区别：

```Cpp
int* p = new int(10);
int* q = p;   //浅拷贝：q和p指向同一块内存

int* p1 = new int(10);
int* q1 = new int(*p1);   //深拷贝：q1指向新内存，内容与p1指向的相同
```

### （2）针对 “对象”

当对象包含动态分配的资源（如指针成员指向堆内存）时，拷贝对象的行为会区分深浅；

**浅拷贝：**复制对象的所有成员变量（包括指针的地址），但不复制指针指向的底层资源。此时两个对象的指针成员会指向同一块内存，可能导致二次释放的问题。**类的默认拷贝构造函数就是浅拷贝**：

```
class A {
public:
    int* data;
    A(int val) : data(new int(val)) {}
};

A a(10);
A b = a; // 浅拷贝：b.data和a.data指向同一块内存
```

**深拷贝：**不仅复制对象的成员变量，还会为指针成员重新分配内存，并复制底层数据，确保两个对象的资源完全独立，互不影响。

例如：**自定义的深拷贝构造函数**

```C++

class A {
public:
    int* data;
    A(int val) : data(new int(val)) {}
    A(const A& other) : data(new int(*(other.data))) {}    // 深拷贝构造函数
};

A a(10);
A b = a; // 深拷贝：b.data指向新内存，内容与a.data相同
```

## 2.10 mutable

​	在 C++ 中，`mutable` 是一个关键字，主要用于**打破 `const` 修饰带来的常量性限制**，允许在特定场景下修改被修饰的变量。它的核心作用是区分 “对象的物理常量性” 和 “逻辑常量性”，常见于以下两种场景：

### 2.10.1 修饰类的非静态成员变量：允许在 `const` 成员函数中修改

```cpp
#include <iostream>
#include <string>
using namespace std;

class Student {
private:
    string _name;
    mutable string _cache;  // 缓存：用于存储计算后的结果，可在const函数中修改
    mutable bool _cacheValid;  // 标记缓存是否有效

public:
    Student(string name) : _name(name), _cacheValid(false) {}

    // const成员函数：逻辑上不修改对象的核心状态（_name）
    string getInfo() const {
        if (!_cacheValid) {
            // 计算结果并缓存（修改mutable变量）
            _cache = "Name: " + _name + ", Status: Active";
            _cacheValid = true;  // 更新缓存状态
        }
        return _cache;
    }
};

int main() {
    const Student s("Alice");  // const对象：理论上不能被修改
    cout << s.getInfo() << endl;  // 调用const成员函数，内部修改了mutable变量
    return 0;
}
```

### 2.10.2 修饰 lambda 表达式中的捕获变量：允许修改按值捕获的变量

​	Lambda 表达式按值捕获变量时，默认捕获的是 “常量副本”（在 lambda 内部不能修改）。若需要在 lambda 中修改按值捕获的变量，需用 `mutable` 修饰 lambda。

```cpp
#include <iostream>
using namespace std;

int main() {
    int x = 10;

    // 普通lambda：按值捕获x，内部不能修改x
    auto lambda1 = [x]() {
        // x++;  // 错误：按值捕获的x默认是const，不能修改
        cout << "lambda1: x = " << x << endl;
    };

    // mutable lambda：允许修改按值捕获的x
    auto lambda2 = [x]() mutable {
        x++;  // 合法：mutable取消了捕获变量的const限制
        cout << "lambda2: x = " << x << endl;
    };

    lambda1();  // 输出：lambda1: x = 10
    lambda2();  // 输出：lambda2: x = 11
    cout << "外部x = " << x << endl;  // 输出：外部x = 10（lambda内部修改的是副本）
    return 0;
}
```

**说明**：

- `lambda1` 按值捕获 `x`，内部 `x` 是 `const` 副本，无法修改。
- `lambda2` 用 `mutable` 修饰后，按值捕获的 `x` 变为 “可修改的副本”，允许在 lambda 内部修改（但不会影响外部的原变量 `x`）。

## 2.11 友元类

​	在 C++ 中，**友元类（Friend Class）** 是一种特殊的类关系：当类 A 被声明为类 B 的友元类时，类 A 的所有成员函数都可以直接访问类 B 的**私有成员（private）** 和**保护成员（protected）**，即使这些成员在类 B 中被限制访问。友元类的核心作用是**打破类的封装性**，允许特定类之间进行更紧密的数据交互，通常用于两个关系非常密切的类（如工具类与被管理类）。

### 友元类的声明语法

在需要被访问的类（如类 B）的内部，使用 `friend` 关键字声明友元类（如类 A）：

```cpp
class B {
    // 声明 A 是 B 的友元类
    friend class A;  // 关键语法
    
private:
    int x;  // 私有成员，仅 B 自身和友元类可访问
protected:
    int y;  // 保护成员，仅 B 自身、子类和友元类可访问
public:
    int z;  // 公共成员，任何类可访问
};
```

此时，类 A 的所有成员函数都可以直接访问类 B 的 `x`（私有）、`y`（保护）和 `z`（公共）成员。

### 友元类的特性

1. **单向性**

   友元关系是单向的。如果类 A 是类 B 的友元，不代表类 B 是类 A 的友元。

   例如：A 可以访问 B 的私有成员，但 B 不能访问 A 的私有成员（除非 A 也声明 B 为友元）。

2. **不可传递性**

   友元关系不能传递。如果 A 是 B 的友元，B 是 C 的友元，不代表 A 是 C 的友元（A 不能访问 C 的私有成员）。

3. **不可继承性**

   友元关系不会被继承。如果类 B 是类 A 的友元，B 的子类不会自动成为 A 的友元（除非显式声明）。





# 3 面向对象

## 3.1 两种创建对象方式

C++中创建对象主要有两种方式：

- 在栈上创建（不使用new）：对象在声明时创建，作用域结束时自动销毁。

- 在堆上创建（使用new）：通过动态内存分配创建，需要手动delete销毁，或者使用智能指针自动管理。

此外，现代C++还推荐使用智能指针（如std::unique_ptr, std::shared_ptr）来管理堆上的对象，以避免内存泄漏。

```C++
// 1.示例：栈上创建对象
MyClass obj;  // 构造函数自动调用,作用域结束时自动调用析构函数

// 2.示例：堆上创建对象
MyClass* ptr = new MyClass();  // 显式调用 new
// ...使用对象...
delete ptr;  // 必须显式释放

#include <memory>
// 使用 unique_ptr（C++11+）
auto obj = std::make_unique<MyClass>();  // 自动管理内存
// 当 obj 离开作用域时自动释放内存
```

## 3.2 什么是抽象类

抽象类：至少存在一个“纯虚函数”。**抽象类不能创建对象**,但可以声明指针和引用

普通的虚函数并不能让类变成抽象类，它只负责给多态机制一个动态绑定的入口。

抽象类指针=“遥控器”，派生类对象=“电视机”。遥控器本身不是电视机，但它能指向任何一个具体电视机，并帮你切换频道（调用接口）

```C++
class Animal {     // 抽象类（有纯虚函数）
public:
    virtual void makeSound() const = 0;  // =0 表示纯虚函数  纯虚函数（必须被子类实现）
};

class Dog : public Animal {        // 具体子类1
public:
    void makeSound() const override {  // 实现纯虚函数
        std::cout << "汪汪！" << std::endl;
    }
};

int main() {
    // Animal animal;  // 错误！不能创建抽象类对象
    Dog dog;
    Animal* animal1 = &dog;        // 通过抽象类指针操作具体对象
    animal1->makeSound();  // 输出：汪汪！
    return 0;
}
```

## 3.3 构造函数

- 如果一个类没有定义任何构造函数，编译器会自动生成一个默认构造函数（不做任何初始化）。
- 如果定义了构造函数，那么编译器就不会再自动生成默认构造函数。
- 但是，如果定义的构造函数的所有参数都有默认值，那么它就可以作为默认构造函数使用。

### 3.3.1 构造函数的初始化列表

成员变量的初始化和它们**定义的顺序有关**，和构造函数初始化列表中出现的先后顺序无关！

对于这个题，创建对象t后，调用show()函数，会进行构造函数初始化列表，按照变量的定义顺序，先对ma赋值，因为编译器的原因，会对申请的空间进行初始化为0xcccccccc（-858993460），因此ma=-858993460，mb=10。

```C++
class Test
{
public:
    Test(int data=10):mb(data),ma(mb){}
    void show(){ cout << "ma:" << ma << "mb:" << mb << endl;}
private:
    int ma;
    int mb;
};

int main(){
    Test t;
    t.show();   // ma:-858993460  mb:10
    return 0; 
}
```

### 3.3.2 构造函数的类型

| 构造函数类型   | 参数形式             | 调用场景                                     | 核心作用                       |
| -------------- | -------------------- | -------------------------------------------- | ------------------------------ |
| 默认构造函数   | 无参数或全默认参数   | 无参创建对象（如`Student s;`）               | 提供默认初始化                 |
| 带参数构造函数 | 自定义参数           | 有参创建对象（如`Student s("Tom", 20, 80)`） | 自定义初始化对象               |
| 拷贝构造函数   | `const 类名&`        | 用已有对象初始化新对象（如`s3 = s2`）        | 复制对象（深拷贝避免资源问题） |
| 移动构造函数   | `类名&&`（右值引用） | 用临时对象初始化新对象（如`s4 = 临时对象`）  | 接管资源，提高效率             |

```C++
#include <iostream>
#include <string>
using namespace std;

class Student {
private:
    string name;
    int age;
    int* score; // 模拟堆资源

public:
    // 1. 默认构造函数（无参数）
    Student() {
        name = "Unknown";
        age = 0;
        score = new int(0); // 初始化堆内存
        cout << "默认构造函数被调用\n";
    }

    // 2. 带参数的构造函数
    Student(string n, int a, int s) {
        name = n;
        age = a;
        score = new int(s); // 用参数初始化堆内存
        cout << "带参数构造函数被调用\n";
    }

    // 3. 拷贝构造函数（参数为const引用）
    Student(const Student& other) {
        name = other.name;
        age = other.age;
        // 深拷贝：重新分配堆内存，避免浅拷贝导致的double free
        score = new int(*other.score); 
        cout << "拷贝构造函数被调用\n";
    }

    // 4. 移动构造函数（参数为右值引用）
    Student(Student&& other) noexcept {
        name = other.name;
        age = other.age;
        // 直接接管other的堆资源，不复制
        score = other.score; 
        other.score = nullptr; // 避免other析构时释放资源
        cout << "移动构造函数被调用\n";
    }

    // 析构函数：释放堆资源
    ~Student() {
        if (score != nullptr) {
            delete score;
            score = nullptr;
        }
        cout << "析构函数被调用\n";
    }

    // 打印信息（辅助函数）
    void print() {
        cout << "Name: " << name << ", Age: " << age 
             << ", Score: " << *score << endl;
    }
};

int main() {
    // 调用默认构造函数
    Student s1; 
    s1.print(); // Name: Unknown, Age: 0, Score: 0

    // 调用带参数的构造函数
    Student s2("Alice", 18, 90); 
    s2.print(); // Name: Alice, Age: 18, Score: 90

    // 调用拷贝构造函数（用s2初始化s3）
    Student s3 = s2; 
    s3.print(); // Name: Alice, Age: 18, Score: 90

    // 调用移动构造函数（用临时对象初始化s4）
    Student s4 = Student("Bob", 19, 85); // 临时对象是右值
    s4.print(); // Name: Bob, Age: 19, Score: 85

    return 0;
}
```

注意：**一个空类默认会生成构造函数,拷贝构造函数,赋值操作符,析构函数**

在 C++ 中，当一个类为空（没有任何用户定义的成员）时，编译器会**自动生成以下 6 个默认成员函数**（C++11 及以后标准）：

- 默认构造函数（无参）

- 拷贝构造函数

- 拷贝赋值运算符（`operator=`）

- 析构函数

- 移动构造函数（C++11 新增）

- 移动赋值运算符（C++11 新增）

```C++
#include <iostream>
using namespace std;

// 空类：没有任何用户定义的成员
class Empty {};

int main() {
    // 1. 调用默认构造函数（编译器生成）
    Empty e1; 

    // 2. 调用拷贝构造函数（编译器生成）
    Empty e2(e1);  // 用e1初始化e2
    Empty e3 = e1; // 等价于拷贝构造

    // 3. 调用拷贝赋值运算符（编译器生成）
    Empty e4;
    e4 = e1;       // 赋值操作

    // 4. 析构函数（编译器生成）：程序结束时自动调用，释放资源（空类无实际资源）
    return 0;
}
```

## 3.4 静态联编和动态联编

  ​		在 C++ 中，**联编（Binding）** 指的是将函数调用与具体的函数实现代码关联起来的过程。根据关联发生的时机，分为**静态联编（Static Binding）** 和**动态联编（Dynamic Binding）**，二者的核心区别在于 “确定调用哪个函数” 的时机不同

###   （1）静态联编

  ​		静态联编也称为**早期绑定（Early Binding）**，指的是**在编译阶段就确定函数调用与函数实现的关联**。编译器在编译时就能明确知道应该调用哪个函数，无需运行时的额外判断。使用场景为：

  - **普通函数调用**（非成员函数、非虚成员函数）；
  - **函数重载**（编译器根据参数类型、个数等确定具体调用版本）；
  - **非虚成员函数的调用**（即使通过对象指针 / 引用调用，也在编译时确定）。

### 	（2）动态联编

​		动态联编也称为**晚期绑定（Late Binding）**，指的是**在程序运行阶段才确定函数调用与函数实现的关联**。编译器在编译时无法确定具体调用哪个函数，需要根据运行时的对象实际类型来判断。

​		动态联编是 C++ 多态（Polymorphism）的核心实现机制，仅适用于**虚函数** 的调用，且需满足：

- 通过**基类的指针或引用**调用虚函数；

- 派生类重写（Override）了基类的虚函数

## 3.5 this指针

​		`this`指针是类的**非静态成员函数**中隐含的一个特殊指针，它**指向当前调用该成员函数的对象**。简单来说，当对象调用成员函数时，`this`指针就代表这个对象本身，用于在成员函数内部访问当前对象的成员（变量或函数）

​		`this`指针是 C++ 实现面向对象的重要机制，它隐式关联了成员函数与调用它的对象，解决了同名变量冲突问题，并支持灵活的对象操作（如链式调用）。

## 3.6 类的几种成员方法

### （1）普通成员方法

- 编译器会添加一个this形参变量
- 属于类的作用域
- 调用该方法时，需要依赖一个对象
- 可以访问对象的私有成员

### （2）static静态成员方法

- 不会生成this形参

- 属于类的作用域

- 用类名作用域来调用方法

- 可以任意访问对象的私有成员，仅限于不依赖对象的成员（只能调用其他的static静态成员）

  注意：静态成员变量一定要在类外进行定义并且初始化。

###     （3）const常成员方法

- 编译器会生成    const 类名 *this   指针
- 调用依赖一个对象，普通对象或者常对象都可以
- 可以任意访问对象的私有成员，但是只能读，不能写
  注意：只要是只读的成员方法，一律实现成const常成员方法

## 3.7 空间配置器

### （1）分离 “内存分配” 与 “对象构造 / 析构”

主要做了四件事情：内存开辟、内存释放、对象构造、对象析构

配置器的职责是**纯粹的 “内存块操作”**（比如分配一段能存`n`个`T`类型对象的内存）；而**对象的构造 / 析构由容器或相关组件（如 “类型萃取” 机制）控制**。这种分离让性能更优：

- 对于简单类型（如`int`、`double`等 POD 类型），构造 / 析构无需额外操作，直接操作内存块即可，节省函数调用开销；
- 对于自定义类型，容器会主动调用构造 / 析构函数，保证对象正确初始化和资源释放。
- 对于空间配置器allocator，通过四个函数allocate、deallocate、construct、destrory来实现

```C++
template<typename T>
class Allocator
{
public:
	T* allocate(size_t size)  // 负责内存开辟
	{
		return (T*)malloc(sizeof(T) * size);
	}

	void deallocate(void* p)  // 负责内存释放
	{
		free(p);
	}

	void construct(T* p, const T& val)  // 负责对象构造（使用定位new）
	{
		new (p) T(val);
	}

	void destroy(T* p)  // 负责对象析构（调用对象的析构函数）
	{
		p->~T();
	}
};
```

## 3.8 运算符的重载

目的：使对象之间的运算和编译器内置类型一样

编译器做对象运算的时候，会调用对象的运算符重载函数（优先调用成员方法），如果没有成员方法，就在全局作用域找合适的运算符重载函数

++运算符的重载：

- 前置++：operator++()
- 后置++：operator++(int)     后置++  括号里面要带参数

```C++
#include <iostream>
using namespace std;

class Complex {
private:
    double real;  // 实部
    double imag;  // 虚部

public:
    // 构造函数
    Complex(double r = 0, double i = 0) : real(r), imag(i) {}

    // 重载+运算符，实现两个复数相加
    Complex operator+(const Complex& other) const;

    // 重载前缀++运算符
    Complex& operator++();

    // 重载后缀++运算符
    Complex operator++(int);

    // 友元函数，重载<<运算符，用于输出复数
    friend ostream& operator<<(ostream& out, const Complex& c);
};

// 实现+运算符重载
Complex Complex::operator+(const Complex& other) const {
    // 复数相加：实部加实部，虚部加虚部
    return Complex(real + other.real, imag + other.imag);
}

// 实现前缀++运算符重载
Complex& Complex::operator++() {
    // 前缀自加：先加后用，这里选择对实部进行加1操作
    real++;
    return *this;
}

// 实现后缀++运算符重载
Complex Complex::operator++(int) {
    // 后缀自加：先用后加，通过参数int区分
    Complex temp = *this;  // 保存当前值
    real++;                // 实部加1
    return temp;           // 返回未加之前的值
}

// 实现<<运算符重载，方便输出复数
ostream& operator<<(ostream& out, const Complex& c) {
    out << c.real;
    if (c.imag >= 0) {
        out << "+";  // 虚部为正时显示加号
    }
    out << c.imag << "i";
    return out;
}

int main() {
    Complex c1(2.5, 3.7);
    Complex c2(1.6, -2.8);

    cout << "初始值：" << endl;
    cout << "c1 = " << c1 << endl;
    cout << "c2 = " << c2 << endl;

    // 测试加法运算
    Complex c3 = c1 + c2;
    cout << "\nc1 + c2 = " << c3 << endl;

    // 测试前缀自加
    ++c1;
    cout << "++c1 = " << c1 << endl;

    // 测试后缀自加
    Complex c4 = c2++;
    cout << "c2++ 运算后，返回值 = " << c4 << endl;
    cout << "c2++ 运算后，c2 = " << c2 << endl;

    return 0;
}
```

## 3.9 继承

### 3.9.1 单继承

<img src="assets/继承.png" alt="继承" style="zoom: 67%;" />

**总结：**

- 外部只能访问对象public的成员，protected和private成员无法直接访问

- 在继承结构中，派生类可以继承基类中的private成员，但派生类无法直接访问

- 在基类中protected定义的成员，可以被派生类访问，但不能被外部访问。private定义的成员，只有自己能访问到，派生类和外部都无法访问

- 私有变量只有自己或者友元函数能访问

- 派生类的访问权限是不会超过继承方式的

**使用继承的好处：**

- 代码的复用
- 在基类中给派生类提供统一的虚函数接口，让派生类进行重写，然后就可以使用多态

**基类和派生类之间的类型转换：**

在继承结构中进行上下类型转化，只支持从下到上的类型转换。（从派生类→基类）

<img src="assets/基类和派生类之间的转换.png" alt="基类和派生类之间的转换" style="zoom: 50%;" />

### 3.9.2多重继承

#### （1）多重继承的对象内存布局

- 派生类（如`ClassC`）继承多个基类（`ClassA`、`ClassB`）时，其对象内存中会**包含所有基类的完整子对象**（每个基类的成员和虚函数相关数据会作为独立部分存在于派生类对象中）。
- 这些基类子对象在内存中占据**不同的位置**，按继承声明的顺序排列（如`ClassC`先继承`ClassA`，再继承`ClassB`，则`ClassA`子对象在前，`ClassB`子对象在后）。

#### （2）基类指针指向派生类对象的地址规则

- 当基类指针（如`ClassA *pA ，ClassB* pB`）指向派生类对象（`ClassC aObject`）时，指针实际指向的是派生类对象中

  对应基类子对象的起始地址

  - `pA`指向`ClassC`对象中`ClassA`子对象的起始地址；
  - `pB`指向`ClassC`对象中`ClassB`子对象的起始地址；
  - 由于两个基类子对象在内存中位置不同，因此`pA`和`pB`的地址**不相等**。

#### （3）派生类指针与第一个基类指针的地址关系

- 在标准 C++ 实现中，**派生类对象的起始地址与第一个基类子对象的起始地址相同**（因第一个基类子对象在内存布局中位于最前方）。

  题目中`ClassA`是`ClassC`的第一个基类，因此`ClassC* pC`（指向整个派生类对象）与`ClassA* pA`（指向第一个基类子对象）的地址**相等**。

```C++
class ClassA
{
public:
    virtual ~ ClassA() {};
    virtual void FunctionA() {};
};
class ClassB
{
public:
    virtual void FunctionB() {};
};
class ClassC : public ClassA,public ClassB
{
public:
};
ClassC aObject;
ClassA* pA=&aObject;
ClassB* pB=&aObject;
ClassC* pC=&aObject;    // pA和pB不相同，pC和pA相同
```





## 3.10 重载、隐藏、覆盖

- **重载关系：**一组函数要重载，必须处在同一作用域当中；且函数名字相同，参数列表不同（基类和派生类有相同名字的成员函数，不算是重载关系）

- **隐藏（作用域的隐藏）关系：**在继承结构中，派生类的同名成员，把基类的同名成员给隐藏调用了

- **覆盖：**如果派生类中的方法和基类继承的某个方法的返回值、函数名、参数列表都相同，而且基类的方法是virtual虚函数，那么派生类的这个方法，会自动处理成虚函数。（进行了虚函数表中虚函数地址的覆盖）

注意：

- **覆盖**仅发生在**虚函数**上，且要求子类重写父类的虚函数（函数签名、返回类型需一致）

- 子类中定义了与父类**同名的非虚函数**时，子类的函数会 “屏蔽” 父类的同名函数。当通过**子类对象或子类指针**调用该函数时，会优先使用子类的版本，而父类的版本被 “**隐藏**” 了。

```C++
class A
{
public:
    void foo()
    {
        printf("1");
    }
    virtual void fun()
    {
        printf("2");
    }
};
class B: public A
{
public:
    void foo()
    {
        printf("3");
    }
    void fun()
    {
        printf("4");
    }
};
int main(void)
{
    A a;
    B b;
    A *p = &a;
    p->foo();     // 1
    p->fun();     // 2
    p = &b;
    p->foo();     // 1
    p->fun();     // 4
    A *ptr = (A *)&b;
    ptr->foo();   // 1
    ptr->fun();   // 4
    return 0;
}
```

## 3.11 虚函数

- 如果类里面定义了虚函数，那么**编译阶段**，编译器给这个类类型产生一个唯一的vftable虚函数表，虚函数表中主要存储的是RTTI指针和虚函数的地址。当程序运行时，每一张虚函数表都会加载到内存的.rodata区。

- 一个类里面定义了虚函数，那么这个类定义的对象，在**运行时**，内存在开辟阶段，多存储一个vfptr虚函数指针，指向相应类型的虚函数表vftable。一个类型定义的多个对象，他们的vfptr指向的都是同一张虚函数表。

- 一个类里面的虚函数的个数，不影响对象内存的大小，影响的是虚函数表的大小。

- 静态成员函数、内联函数、构造函数 不能声明为虚函数

```c++
class Base{
public:
    Base(int data=10):ma(data){}
    
    virtual void show(){cout<<"Base::show()"<<endl;}
    virtual void show(int){cout<<"Base::show(int)"<<endl;}
protected:
    int ma;
}
```

<img src="assets/虚函数表.png" alt="虚函数表" style="zoom:50%;" />

## 3.12 静态绑定和动态绑定

### （1）静态绑定

​		又称 “编译时绑定”，指**在程序编译阶段**，编译器就根据**变量 / 指针的 “声明类型”**（而非实际指向的对象类型）确定要调用的函数版本。 **静态绑定的适用场景：**

​		只要不满足 “基类指针 / 引用 + 虚函数” 的组合，均为静态绑定，常见场景：

- 调用**普通函数**（非虚函数）、**静态成员函数**（`static` 修饰）；

- 通过**对象本身**（而非指针 / 引用）调用虚函数；

- 在**构造函数 / 析构函数**中调用虚函数（此时对象类型不完整，强制静态绑定）；

- 虚函数被 `final` 修饰（禁止派生类重写，无多态版本）。

### （2）动态绑定

又称 “运行时绑定”，指**在程序运行阶段**，根据**指针 / 引用实际指向的对象类型**（而非声明类型）确定要调用的函数版本。

基类指针调用虚函数时，无论指向的是基类对象还是派生类对象，只要满足 **“基类指针 / 引用 + 虚函数” 的条件，就是动态绑定。**

**动态绑定的适用场景应该是：通过指针或引用调用虚函数**，而不仅仅是 “基类的指针或引用”。

### （3）两者对比

| 对比维度           | 静态绑定                               | 动态绑定                                 |
| ------------------ | -------------------------------------- | ---------------------------------------- |
| 绑定时机           | 程序编译阶段                           | 程序运行阶段                             |
| 确定函数版本的依据 | 变量 / 指针的 “声明类型”               | 指针 / 引用 “实际指向的对象类型”         |
| 依赖条件           | 无需虚函数，不依赖多态                 | 必须满足：① 虚函数重写；② 指针 / 引用    |
| 适用函数类型       | 普通函数、静态函数、对象调用的虚函数等 | 基类指针 / 引用调用的虚函数              |
| 效率               | 高（编译时已确定，无运行时开销）       | 稍低（运行时需通过 “虚函数表” 查找函数） |
| 灵活性             | 低（无法适应对象类型变化）             | 高（支持多态，动态适配对象类型）         |

```C++
#include <iostream>
using namespace std;

// 基类
class Base {
public:
    // 1. 普通函数（非虚函数）
    void non_virtual_func() {
        cout << "Base: 普通函数（静态绑定）" << endl;
    }

    // 2. 虚函数（支持动态绑定）
    virtual void virtual_func() {
        cout << "Base: 虚函数（可能动态绑定）" << endl;
    }

    // 3. 构造函数（内部调用虚函数）
    Base() {
        cout << "Base 构造函数调用：";
        virtual_func(); // 构造函数中调用虚函数
    }

    // 4. 析构函数（内部调用虚函数）
    ~Base() {
        cout << "Base 析构函数调用：";
        virtual_func(); // 析构函数中调用虚函数
    }
};

// 派生类（公有继承 Base）
class Derived : public Base {
public:
    // 重写普通函数（非虚函数，不支持多态）
    void non_virtual_func() {
        cout << "Derived: 普通函数（静态绑定）" << endl;
    }

    // 重写虚函数（必须加 override 明确重写）
    void virtual_func() override {
        cout << "Derived: 虚函数（可能动态绑定）" << endl;
    }

    // 派生类构造函数
    Derived() {
        cout << "Derived 构造函数调用：";
        virtual_func();
    }

    // 派生类析构函数（必须加 virtual，否则基类指针析构时不触发多态）
    ~Derived() override {
        cout << "Derived 析构函数调用：";
        virtual_func();
    }
};

int main() {
    // 场景1：普通函数调用（静态绑定）
    cout << "=== 场景1：普通函数（非虚函数） ===" << endl;
    Base* base_ptr1 = new Derived(); // 基类指针指向派生类对象
    base_ptr1->non_virtual_func();   // 静态绑定：按声明类型 Base 调用
    delete base_ptr1;
    cout << endl;

    // 场景2：对象直接调用虚函数（静态绑定）
    cout << "=== 场景2：对象直接调用虚函数 ===" << endl;
    Derived der_obj;                 // 派生类对象
    der_obj.virtual_func();          // 静态绑定：按对象实际类型 Derived 调用
    cout << endl;

    // 场景3：基类指针指向派生类，调用虚函数（动态绑定）
    cout << "=== 场景3：基类指针 + 虚函数（动态绑定） ===" << endl;
    Base* base_ptr2 = new Derived(); // 基类指针指向派生类对象
    base_ptr2->virtual_func();       // 动态绑定：按实际对象类型 Derived 调用
    delete base_ptr2;                // 析构时动态绑定（因基类析构是虚函数）
    cout << endl;

    return 0;
}
```

## 3.13 多态

### （1）静态多态（编译时多态）

静态多态指**在编译阶段就已确定要调用的具体函数**，其核心是 “编译期绑定”，主要通过以下机制实现：

- **函数重载**：同一作用域内的同名函数，因参数列表（参数类型、个数、顺序）不同而形成重载。编译时编译器会根据实参的类型 / 数量，匹配到唯一对应的函数（通过 “名字粉碎” 技术生成不同的内部标识）。
- **模板（函数模板 / 类模板）**：通过 “参数化类型” 实现多态，编译器在编译期会根据传入的具体类型，实例化出针对该类型的具体函数 / 类（模板的 “单态化”）。例如`template <typename T> void swap(T& a, T& b)`可适配 int、double 等各种类型，编译后会生成多个具体版本的`swap`函数。

### （2）动态多态（运行时多态）

动态多态指**在程序运行阶段才确定要调用的具体函数**，其核心是 “运行期绑定”，需满足以下条件：

- 基于继承结构：存在基类和派生类的继承关系；

- 基类中声明虚函数：基类的成员函数需用`virtual`关键字修饰；

- 派生类重写（override）虚函数：派生类的函数需与基类虚函数的 “函数签名”（参数列表、const 属性等）和返回类型（协变返回类型除外）完全一致，否则会形成 “隐藏” 而非 “重写”；

- 通过基类指针 / 引用调用：必须通过基类的指针或引用指向派生类对象，才能触发动态绑定。

## 3.14 函数对象

把有operator()小括号运算符重载函数的对象，称为函数对象，或者仿函数。有以下优点：

- 通过函数对象调用 operator () 比通过函数指针调用函数更高效，是因为函数对象的 operator () 在多数情况下能被编译器进行内联优化（inline）。
- 因为函数对象是用类生成的，所以可添加相关的成员变量，用来记录函数对象使用时的更多信息

```C++
#include <iostream>

// 定义一个函数对象类（仿函数），用于累加计算
class Adder {
private:
    int total;  // 成员变量，用于记录累加的中间结果（保存状态）
public:
    // 构造函数初始化累加值
    Adder(int init = 0) : total(init) {}

    // 重载()运算符，实现累加逻辑
    int operator()(int num) {
        total += num;  // 每次调用都更新状态
        return total;  // 返回当前累加结果
    }

    // 获取当前累加总和（可选，用于展示状态）
    int getTotal() const {
        return total;
    }
};

int main() {
    // 创建函数对象实例（初始累加值为10）
    Adder adder(10);

    // 像调用函数一样使用对象
    std::cout << adder(5) << std::endl;   // 10+5=15，输出15
    std::cout << adder(3) << std::endl;   // 15+3=18，输出18
    std::cout << adder(7) << std::endl;   // 18+7=25，输出25

    // 查看最终累加结果（通过成员函数获取状态）
    std::cout << "最终总和：" << adder.getTotal() << std::endl;  // 输出25

    return 0;
}
```

## 3.15 对象优化的规则

- 函数参数传递过程中，对象优先按引用传递，不要按值传递
- 函数返回对象时，优先返回一个临时对象，而不是返回局部定义的对象
- 接收返回值是对象的函数调用时，优先按初始化的方式接收，不要按赋值的方式接收

- **利用移动语义（C++11+）**：对临时对象或不再使用的局部对象，用 `std::move` 触发移动构造 / 移动赋值，避免深拷贝。

- **避免不必要的拷贝构造**：通过 `const` 引用传递只读对象，或用 `emplace` 直接在容器中构造对象（替代 `insert`）。

- **最小化临时对象的产生**：避免在循环或高频调用中创建临时对象（如字符串拼接可先 reserve 空间）

先定义一个带日志的 `MyString` 类，便于观察构造 / 拷贝 / 移动行为：

```cpp
#include <iostream>
#include <cstring>
using namespace std;

class MyString {
private:
    char* data;
    int len;

public:
    // 构造函数
    MyString(const char* str = "") {
        len = strlen(str);
        data = new char[len + 1];
        strcpy(data, str);
        cout << "构造：" << data << "（地址：" << (void*)data << "）\n";
    }

    // 拷贝构造（深拷贝，开销大）
    MyString(const MyString& other) {
        len = other.len;
        data = new char[len + 1];
        strcpy(data, other.data);
        cout << "拷贝构造：" << data << "（地址：" << (void*)data << "）\n";
    }

    // 移动构造（转移资源，开销小）
    MyString(MyString&& other) noexcept {
        len = other.len;
        data = other.data;  // 直接接管资源
        other.data = nullptr;
        other.len = 0;
        cout << "移动构造：" << data << "（地址：" << (void*)data << "）\n";
    }

    // 赋值运算符（深拷贝）
    MyString& operator=(const MyString& other) {
        if (this != &other) {
            delete[] data;
            len = other.len;
            data = new char[len + 1];
            strcpy(data, other.data);
            cout << "拷贝赋值：" << data << "（地址：" << (void*)data << "）\n";
        }
        return *this;
    }

    // 移动赋值
    MyString& operator=(MyString&& other) noexcept {
        if (this != &other) {
            delete[] data;
            data = other.data;  // 接管资源
            len = other.len;
            other.data = nullptr;
            other.len = 0;
            cout << "移动赋值：" << data << "（地址：" << (void*)data << "）\n";
        }
        return *this;
    }

    ~MyString() {
        if (data) cout << "析构：" << data << "（地址：" << (void*)data << "）\n";
        else cout << "析构：空对象\n";
        delete[] data;
    }

    // 获取字符串长度
    int length() const { return len; }
};
```

#### 规则 1：函数参数优先按引用传递（避免按值传递）

```cpp
// 反例：按值传递（会触发拷贝构造，开销大）
void badPrint(MyString s) {
    cout << "打印：" << s.length() << " 字节\n";
}

// 正例：按 const 引用传递（无拷贝，直接访问原对象）
void goodPrint(const MyString& s) {
    cout << "打印：" << s.length() << " 字节\n";
}

// 调用对比
int main() {
    MyString str("test");
    cout << "--- 按值传递 ---\n";
    badPrint(str);  // 触发拷贝构造
    cout << "--- 按引用传递 ---\n";
    goodPrint(str); // 无拷贝
    return 0;
}
```

**输出差异**：按值传递多一次拷贝构造和析构，引用传递无额外开销。

#### 规则 2：函数返回对象时，优先返回临时对象（触发移动或 RVO）

```cpp
// 反例：返回局部对象（可能触发拷贝，C++17前未必优化）
MyString badReturn() {
    MyString local("local");
    return local;  // 返回局部变量，可能拷贝
}

// 正例：返回临时对象（直接触发移动构造或RVO优化）
MyString goodReturn() {
    return MyString("temporary");  // 返回临时对象
}

// 调用对比
int main() {
    cout << "--- 返回局部对象 ---\n";
    MyString a = badReturn();
    cout << "--- 返回临时对象 ---\n";
    MyString b = goodReturn();
    return 0;
}
```

**输出差异**：返回临时对象可避免局部变量的拷贝（C++17 强制 RVO 优化，甚至无移动）。

#### 规则 3：接收返回值时，优先用初始化（而非赋值）

```cpp
int main() {
    cout << "--- 初始化接收（推荐） ---\n";
    MyString c = goodReturn();  // 直接构造或移动构造

    cout << "--- 赋值接收（不推荐） ---\n";
    MyString d;  // 先默认构造
    d = goodReturn();  // 再移动赋值（多一次默认构造+析构）
    return 0;
}
```

**输出差异**：初始化方式少一次默认构造和析构，更高效。

#### 规则 4：利用移动语义（`std::move`）转移资源

```cpp
void useResource(MyString s) {
    cout << "使用资源：" << s.length() << "\n";
}

int main() {
    MyString e("需要转移的资源");
    // 反例：直接传递，触发拷贝
    useResource(e);  // e 仍持有资源，需拷贝

    // 正例：用 std::move 转移，触发移动构造
    useResource(std::move(e));  // e 不再持有资源，无拷贝
    return 0;
}
```

**输出差异**：`std::move` **将左值转为右值**，触发移动构造（转移资源而非拷贝）。

#### 规则 5：用 `emplace` 代替 `insert`（容器操作）

```cpp
#include <vector>

int main() {
    vector<MyString> vec;

    cout << "--- insert（插入对象，触发拷贝） ---\n";
    MyString f("insert");
    vec.insert(vec.end(), f);  // 拷贝构造

    cout << "--- emplace（直接构造，无拷贝） ---\n";
    vec.emplace(vec.end(), "emplace");  // 直接在容器中构造，无中间对象
    return 0;
}
```

**输出差异**：`emplace` 直接在容器内存中构造对象，避免 `insert` 所需的临时对象拷贝。

#### 规则 6：最小化临时对象（如字符串拼接）

```cpp
// 反例：频繁创建临时对象
MyString badConcat(const MyString& a, const MyString& b) {
    MyString temp;  // 临时对象1
    // 实际实现需拼接 a 和 b 到 temp（省略细节）
    return temp;    // 可能产生临时对象2
}

// 正例：预留空间，减少临时对象
MyString goodConcat(const MyString& a, const MyString& b) {
    MyString temp;
    temp.reserve(a.length() + b.length());  // 预留足够空间，避免中途扩容
    // 拼接逻辑（省略）
    return temp;  // 优化后可能无临时对象
}
```

**核心**：提前分配足够内存，避免因容量不足导致的多次内存分配和对象拷贝。

**总结**

​		对象优化的核心是**减少不必要的拷贝构造和析构**，通过引用传递、移动语义、编译器优化（RVO）、容器 emplace 等手段，将 “深拷贝” 开销转化为 “资源转移” 或 “直接构造”，尤其适合大对象（如字符串、容器）的高频操作场景。



# 4 模板

## 4.1函数模板

- 函数模板是一个**模板定义**，是生成具体函数的 "蓝图" 或 "模具"，本身不是可执行的函数。模板的意义是：类型也可以初始化了。编译器不编译，因为类型不知道。

```C++
// 函数模板（模板定义）
template <typename T>
T add(T a, T b) {
    return a + b;
}
```

- 模板函数

  - 本质：是由函数模板实例化产生的具体函数，是可执行的函数
- 在调用点，编译器根据用户指定的类型，从原模板实例化一份函数代码（需要被编译器编译），每种类型实例化生成独立的函数代码，与普通函数一样可被调用。

```C++
  // 由函数模板实例化生成的模板函数（int类型）
int add(int a, int b) {
    return a + b;
}
```

**函数模板**是 "模板"，是抽象的定义，不占用内存；

​	**函数**是 "实例"，是具体的函数，由模板生成，占用内存并可执行。

​	简单说：**函数模板是 "图纸"，模板函数是根据图纸造出的 "实物"**。

- 实例化推演：根据用户传入的实参类型，来推导出模板类型参数的具体类型。

- 模板的特例化：模板特例化是为特定类型提供专门的实现，当使用该类型时，会优先调用特例化版本而不是通用模板。

```C++
template <typename T>          // 通用函数模板：返回两个同类型参数中的较大值
T max(T a, T b) {
    std::cout << "使用通用模板: ";
    return (a > b) ? a : b;
}

template <>                   // 模板特例化：针对const char*类型（C风格字符串）
const char* max<const char*>(const char* a, const char* b) {
    std::cout << "使用const char*特例化模板: ";
    // 比较字符串内容而非指针地址
    return (std::strcmp(a, b) > 0) ? a : b;
}

int main() {
    int num1 = 10, num2 = 20;  // 1. 使用通用模板（int类型）
    std::cout << "较大的整数：" << max(num1, num2) << std::endl;
    
    double d1 = 3.14, d2 = 2.71;  // 2. 使用通用模板（double类型）
    std::cout << "较大的小数：" << max(d1, d2) << std::endl;
    
    std::string s1 = "apple", s2 = "banana";    // 3. 使用通用模板（std::string类型）
    std::cout << "较大的字符串：" << max(s1, s2) << std::endl;
    
    const char* cstr1 = "hello";   // 4. 使用const char*的特例化版本
    const char* cstr2 = "world";
    std::cout << "较大的C风格字符串：" << max(cstr1, cstr2) << std::endl;
    
    return 0;
}
```

- 模板代码在调用之前，一定要看到模板定义的地方，这样才能够进行正常的实例化，产生能够被编译器编译的代码。所以模板代码都是放在头文件当中的
- 模版函数、模板的特例化、非模板函数的重载三者之间的关系

​		他们三者核心关系体现在**编译器对函数调用的匹配规则**上。

​		（1）概念回顾

​		**模板函数（通用模板）**：带类型参数的函数模板（如`template <typename T> void func(T a)`），是生成具体函数的 “蓝图”，可通过实参推演自动实例化出针对特定类型的函数。

​		**模板的特例化**：针对模板中特定类型（如`int`、`const char*`）的特殊实现（如`template <> void func<int>(int a)`），用于覆盖通用模板在该类型下的默认行为。

​		**非模板函数的重载**：与模板函数同名但无模板参数的普通函数（如`void func(int a)`），是独立的函数实体，不依赖模板。

​		（2）核心关系：调用优先级

​		当程序中同时存在这三类函数时，编译器会按照 **“最具体匹配” 原则 ** 选择调用版本，优先级从高到低为：

​					**非模板函数（普通重载） > 模板的特例化 > 通用模板函数**

为什么是这个顺序？

- 非模板函数是**完全具体**的实现，不需要编译器实例化，因此优先匹配。
- 模板特例化是针对**特定类型**的特殊实现，比通用模板更具体，因此在相同类型下优先于通用模板。
- 通用模板是**最泛化**的实现，仅在没有更具体的匹配（非模板函数或特例化）时才被实例化调用。

```C++
#include <iostream>

// 1. 通用模板函数（最泛化）
template <typename T>
void print(T a) {
    std::cout << "通用模板: " << a << std::endl;
}

// 2. 模板特例化（针对int类型，比通用模板具体）
template <>
void print<int>(int a) {
    std::cout << "int特例化模板: " << a << std::endl;
}

// 3. 非模板函数（普通重载，最具体）
void print(int a) {
    std::cout << "非模板重载: " << a << std::endl;
}

int main() {
    print(10);      // 调用：非模板函数（优先级最高）
    print(3.14);    // 调用：通用模板（无更具体的匹配）
    print('a');     // 调用：通用模板（无更具体的匹配）
    print<int>(20); // 显式指定模板参数，强制调用int特例化
    return 0;
}
```

## 4.2 类模板

实现一个vector向量容器

```C++
template<typename T>
class vector {
public:
	vector(int size = 10) {
		_first = new T[size];
		_last = _first;
		_end = _first + size;
	}

	~vector() {
		delete[] _first;
		_first = _last = _end = nullptr;
	
	}

	vector(const vector<T>& rhs)       // 拷贝构造函数
	{
		int size = rhs._end - rhs._first;
		_first = new T[size];
		int len = rhs._last - rhs._first;
		for (int i = 0; i < len; ++i)
		{
			_first[i] = rhs._first[i];
		} 
		_last = _first + len;
		_end = _first+ size;
	}

	vector<T>& operator=(const vector<T>& rhs)     //赋值构造函数
	{
		if(this==&rhs)
			return *this;
		delete[] _first;
		int size = rhs._end - rhs._first;
		_first = new T[size];
		int len = rhs._last - rhs._first;
		for (int i = 0; i < len; ++i)
		{
			_first[i] = rhs._first[i];
		}
		_last = _first + len;
		_end = _first + size;

	}

	void push_back(const T& val)
	{
		if (full())
			expand();
		*_last++ = val;
	}

	void pop_back()
	{
		if (empty())
			return;
		--_last;
	}

	T back()const
	{
		return *(_last - 1);
	}
	bool full()const { return _last == _end; }
	bool empty()const { return _last == _first; }
	int size()const { return _last - _first; }

private:
	T* _first;   //指向数组起始位置
	T* _last;    //指向数组最后一个元素的下一个位置
	T* _end;     //指向数组的最后一个位置

	void expand()
	{
		int size = _end - _first;
		T* ptmp = new T[size * 2];
		for (int i = 0; i < size; ++i)
		{
			ptmp[i] = _first[i];
		}
		delete[] _first;
		_first = ptmp;
		_last = _first + size;
		_end = _first + size * 2;
	}
};

int main()
{
	vector<int> vec;
	for (int i = 0; i < 20; ++i)
	{
		vec.push_back(rand() % 100);
	}

	while (!vec.empty())
	{
		cout << vec.back() << " ";
		vec.pop_back();
	}
	cout << endl;

	return 0;
}
```

## 4.3 特例化

- **完全特化**：为模板的**所有模板参数**指定具体类型，生成一个针对该特定参数组合的独立实现。
- **部分特化（偏特化）**：为模板的**部分模板参数**指定具体类型，剩余参数仍保留为模板参数，生成一个 “半通用” 的特化版本。

```C++
#include <iostream>
using namespace std;

// 1. 主模板（通用版本）
template <typename T, typename U>
class MyTemplate {
public:
    void print() {
        cout << "通用版本：T = " << typeid(T).name() 
             << ", U = " << typeid(U).name() << endl;
    }
};

// 2. 完全特化：为 T=int、U=double 这一特定组合提供专门实现
template <>  // 完全特化需空模板参数列表
class MyTemplate<int, double> {
public:
    void print() {
        cout << "完全特化版本：T=int, U=double" << endl;
    }
};

// 3. 部分特化：为 T=int（第一个参数固定为int），第二个参数仍为模板参数 U
template <typename U>  // 仅保留部分参数为模板
class MyTemplate<int, U> {
public:
    void print() {
        cout << "部分特化版本：T=int, U = " << typeid(U).name() << endl;
    }
};

int main() {
    MyTemplate<char, float> t1;    // 使用通用版本
    MyTemplate<int, double> t2;    // 使用完全特化版本
    MyTemplate<int, string> t3;    // 使用部分特化版本（T=int，U=string）
    
    t1.print();  // 输出：通用版本：T = char, U = float
    t2.print();  // 输出：完全特化版本：T=int, U=double
    t3.print();  // 输出：部分特化版本：T=int, U = string
    return 0;
}
```



# 5 STL

## 5.1 迭代器

​	可以把迭代器理解为 **“带逻辑的指针”**—— 不仅存储元素的地址，还关联着容器的结构规则。当容器的 “底层支撑”（内存、节点关系等）被改变时，迭代器的 “指向逻辑” 就会被破坏，从而失效。

功能：提供一种统一的方式，**来透明的遍历容器**

迭代器失效的3种情况：

- 当容器调用erase方法后，从当前位置到容器末尾元素的所有迭代器全部失效了
- 当容器调用insert方法后，从当前位置到容器末尾元素的所有迭代器全部失效了
- 对于insert方法来说，如果引起容器内存扩容，那么原来容器的所有迭代器就全部失效了

怎样解决失效的问题：

​	对插入/删除点的迭代器进行更新操作

```C++
#include <iostream>
#include <vector>
using namespace std;

int main() {
    vector<int> v = {1, 2, 3, 4, 5};
    auto it = v.begin();    // 情况1：erase导致迭代器失效及解决
    // 正确做法：用erase的返回值更新迭代器（返回下一个有效迭代器）
    while (it != v.end()) {
        if (*it % 2 == 0) { // 删除偶数
            it = v.erase(it); // 关键：更新迭代器
        } else {
            ++it; // 非删除情况正常递增
        }
    }
    // 输出结果：1 3 5（偶数已被正确删除）
    for (int num : v) cout << num << " ";
    cout << endl << endl;

    // 重置vector用于测试
    v = {1, 2, 3, 4, 5};

    // 情况2：insert（未扩容）导致迭代器失效及解决
    it = v.begin() + 2; // 指向元素3
    // 错误做法：插入后原迭代器（及后面）失效，需用返回值更新
    it = v.insert(it, 10); // 正确做法：插入10到3的位置，返回指向10的迭代器
    cout << "插入位置元素：" << *it << "，下一个元素：" << *(++it) << endl;
    // 输出结果：1 2 10 3 4 5（插入成功）
    for (int num : v) cout << num << " ";
    cout << endl << endl;


    // 重置vector并预留空间（避免扩容），再测试扩容场景
    v = {1, 2, 3};
    v.reserve(5); // 预留5个元素空间（此时容量足够，插入不会扩容）
    cout << "=== 测试insert（扩容）导致的迭代器失效 ===" << endl;
    it = v.begin() + 1; // 指向元素2
    cout << "扩容前容量：" << v.capacity() << endl;

    // 插入大量元素导致扩容（超过预留容量）
    for (int i = 0; i < 5; ++i) {
        v.insert(it, 100 + i);
    }
    cout << "扩容后容量：" << v.capacity() << endl;

    // 错误：扩容后原迭代器it已失效，直接使用会崩溃
    // cout << *it << endl; // 这行代码会导致未定义行为

    // 正确做法：重新获取迭代器（通过位置偏移）
    it = v.begin() + 1; // 重新定位到逻辑上的目标位置
    cout << "扩容后重新获取的迭代器指向：" << *it << endl;
    // 输出当前vector内容
    for (int num : v) cout << num << " ";
    cout << endl;

    return 0;
}
```

## 5.2 顺序容器

### （1）vector容器

底层数据结构：动态开辟的数组，内存是连续的，当空间不够时，每次以原来**空间大小的2倍**进行扩容

```C++
vector<int> vec;
//增加
vec.push_back(20);   //末尾添加20元素   O(1)  有可能发生扩容
vec.insert(it,20);   //在it迭代器指向位置插入20元素      O(n)

//删除
vec.pop_back();      //删除末尾元素
vec.earse(it);       //删除it迭代器指向的元素   O(n)

//查询
operate[];           //下标的随机访问
iterator;            //通过迭代器查询
find,for_each,foreach;     //通过迭代器实现的查询

//常用方法
size(),empty(),reserve(),resize(),swap();
```

注意：对容器进行连续插入或者删除操作(insert/erase)，**一定要更新迭代器**，否则第一次insert或者earse完成，迭代器就失效了。

### （2）deque容器

双端队列（两端都可进可出），底层内存**并不是完全连续存储的**

底层数据结构：动态开辟的二维数组（也称为分段数组或块数组），这种结构结合了数组和链表的优点，既能高效地在两端进行插入和删除操作，又能提供随机访问的能力。

```C++
deque<int> deq;
//增加
deq.push_back(20);         // 从末尾添加元素   O(1)
deq.push_front(20);        // 从首部添加元素   O(1)
deq.insert(it,20);         // it迭代器添加元素   O(n)

//删除
deq.pop_back();            // 从末尾删除元素   O(1)
deq.pop_front();           // 从首部删除元素   O(1)
deq.earse(it);             // 从it指向的位置删除元素  O(1)

//查询
iterator                   // 通过迭代器查询
```

### （3）list容器

底层数据结构：双向循环链表

增删改查和deque一样

## 5.3 容器适配器

- 适配器底层没有自己的数据结构，它是另外一个容器的封装，它的方法全部由底层依赖的容器进行实现（stack依赖deque、queue依赖deque、priority_queue依赖vector）
- 没有实现自己的迭代器
- stack：push、pop、top、empty、size
- queue：push、pop、front、back、empty、size
- priority_queue：push、pop、top、empty、size

## 5.4 关联式容器

（1）无序关联容器

​		元素无序，底层实现：哈希表，平均 O (1) 查找效率

（2）有序关联容器

​		元素按键的升序排列，支持范围查找，键的比较通过`less<Key>`（默认）或自定义比较器实现。底层：红黑树，O (log n) 查找效率

| 容器类型             | 底层结构 | 键特性（唯一 / 有序） | 核心特点                        | 典型用法场景                    |
| -------------------- | -------- | --------------------- | ------------------------------- | ------------------------------- |
| `set`                | 红黑树   | 键唯一、有序          | 去重 + 排序，键即值             | 存储唯一 ID、排序后的不重复数据 |
| `multiset`           | 红黑树   | 键可重复、有序        | 允许重复 + 排序                 | 统计成绩次数、可重复的排序数据  |
| `map`                | 红黑树   | 键唯一、有序          | 键值对映射 + 排序，通过键访问值 | 字典、按名称排序的配置表        |
| `multimap`           | 红黑树   | 键可重复、有序        | 一对多映射 + 排序               | 学生 - 课程表（一个学生多门课） |
| `unordered_set`      | 哈希表   | 键唯一、无序          | 去重，高效查找（平均 O (1)）    | 查重、缓存存储                  |
| `unordered_multiset` | 哈希表   | 键可重复、无序        | 允许重复，高效查找              | 频率统计、允许重复的快速查询    |
| `unordered_map`      | 哈希表   | 键唯一、无序          | 键值对映射，高效查找            | 哈希表、缓存表、快速键值查询    |
| `unordered_multimap` | 哈希表   | 键可重复、无序        | 一对多映射，高效查找            | 快速查询一个键对应的多个值      |

## 5.5 STL中的绑定器

​	`bind1st` 和 `bind2nd` 用于将**二元函数（需要两个参数的函数 / 仿函数）** 转换为**一元函数（只需要一个参数）**，方便与 STL 算法（如 `find_if`、`count_if` 等需要一元谓词的算法）配合使用。

- **`bind1st(f, val)`**：将二元函数 `f` 的**第一个参数绑定为固定值 `val`**，返回一个一元函数。调用该一元函数时，传入的参数会作为 `f` 的第二个参数。    等效逻辑：`f(val, x)`（`x` 是后续传入的参数）。
- **`bind2nd(f, val)`**：将二元函数 `f` 的**第二个参数绑定为固定值 `val`**，返回一个一元函数。调用该一元函数时，传入的参数会作为 `f` 的第一个参数。    等效逻辑：`f(x, val)`（`x` 是后续传入的参数）。
- 局限性：只能处理**二元函数**，无法适配更多参数的函数；

```c++
#include <iostream>
#include <vector>
#include <algorithm>
#include <functional> // 包含 bind1st、bind2nd

using namespace std;

int main() {
    vector<int> nums = {1, 3, 6, 8, 2, 10};

    // 1. 使用 bind2nd：将 less<int>() 的第二个参数绑定为 5，生成一元函数：x < 5
    // 查找第一个满足 x < 5 的元素
    auto it1 = find_if(nums.begin(), nums.end(), bind2nd(less<int>(), 5));
    if (it1 != nums.end()) {
        cout << "第一个小于 5 的元素：" << *it1 << endl; // 输出：1
    }

    // 2. 使用 bind1st：将 less<int>() 的第一个参数绑定为 5，生成一元函数：5 < x
    // 查找第一个满足 5 < x 的元素
    auto it2 = find_if(nums.begin(), nums.end(), bind1st(less<int>(), 5));
    if (it2 != nums.end()) {
        cout << "第一个大于 5 的元素：" << *it2 << endl; // 输出：6
    }

    return 0;
}
```

## 5.6 sting用法大全

| 类别           | 函数 / 操作                | 用法说明                                                     |
| -------------- | -------------------------- | ------------------------------------------------------------ |
| **构造与赋值** | `string s;`                | 默认构造：创建空字符串                                       |
|                | `string s("abc");`         | 用 C 风格字符串（`const char*`）初始化                       |
|                | `string s(5, 'a');`        | 创建包含 5 个字符 'a' 的字符串                               |
|                | `string s(other);`         | 拷贝构造：用另一个`string`对象初始化                         |
|                | `s = "def";`               | 赋值：将字符串内容替换为 "def"（支持`string`或 C 风格字符串赋值） |
| **长度与容量** | `s.size()`                 | 返回字符串中字符的数量（与`length()`功能相同）               |
|                | `s.length()`               | 同`size()`，返回字符数                                       |
|                | `s.empty()`                | 判断字符串是否为空（空则返回`true`）                         |
|                | `s.capacity()`             | 返回当前内存中可容纳的最大字符数（不重新分配内存的情况下）   |
|                | `s.reserve(n)`             | 预留至少能容纳`n`个字符的内存空间（不改变实际字符数，优化性能） |
|                | `s.resize(n, 'a')`         | 调整字符串长度为`n`：若`n`大于原长度，用字符 'a' 填充；若小于，截断尾部 |
| **访问字符**   | `s[i]`                     | 访问索引`i`处的字符（不检查越界，越界行为未定义）            |
|                | `s.at(i)`                  | 访问索引`i`处的字符（越界时抛出`out_of_range`异常）          |
|                | `s.front()`                | 返回第一个字符（等价于`s[0]`，字符串非空时有效）             |
|                | `s.back()`                 | 返回最后一个字符（等价于`s[s.size()-1]`，字符串非空时有效）  |
| **拼接操作**   | `s += "xyz";`              | 尾部拼接字符串（支持`string`、`char`、C 风格字符串）         |
|                | `s.append("123")`          | 尾部追加字符串（功能同`+=`，可指定追加长度，如`s.append("123", 2)`追加 "12"） |
| **比较操作**   | `s1 == s2`                 | 判断两个字符串是否相等（区分大小写）                         |
|                | `s1 != s2`                 | 判断两个字符串是否不相等                                     |
|                | `s1 < s2`                  | 按字典序比较：`s1`是否小于`s2`（其他比较符`>`, `<=`, `>=`类似） |
|                | `s.compare("abc")`         | 比较当前字符串与目标字符串：返回 0（相等）、正数（当前大）、负数（当前小） |
| **查找操作**   | `s.find("ab")`             | 从头部开始查找子串 "ab"，返回首次出现的起始索引；未找到返回`string::npos` |
|                | `s.rfind("ab")`            | 从尾部开始查找子串 "ab"，返回末次出现的起始索引；未找到返回`string::npos` |
|                | `s.find_first_of("xyz")`   | 查找 "xyz" 中任意字符首次出现的索引；未找到返回`string::npos` |
|                | `s.find_last_of("xyz")`    | 查找 "xyz" 中任意字符末次出现的索引；未找到返回`string::npos` |
| **子串提取**   | `s.substr(pos, len)`       | 从索引`pos`开始，提取长度为`len`的子串；`len`默认取到字符串末尾 |
| **修改操作**   | `s.insert(pos, "abc")`     | 在索引`pos`处插入字符串 "abc"                                |
|                | `s.erase(pos, len)`        | 从索引`pos`开始，删除长度为`len`的字符；`len`默认删到末尾    |
|                | `s.replace(pos, len, "x")` | 从索引`pos`开始，用 "x" 替换长度为`len`的字符                |
|                | `s.clear()`                | 清空字符串（长度变为 0，容量可能不变）                       |
| **其他常用**   | `s.c_str()`                | 返回 C 风格字符串（`const char*`），末尾带 '\0'，用于兼容 C 接口 |
|                | `s.swap(other)`            | 交换当前字符串与`other`的内容（高效，不涉及内存分配）        |
|                | `to_string(123)`           | 非成员函数：将数值（如 int、double）转换为`string`           |

# 6 C++11特性

## 6.1智能指针

### 6.1.1不带计数器的智能指针

​	只有一个指针管理资源

（1）auto_ptr

​		C++库本身有，但不推荐使用

（2）scoped_ptr

​		用的很少，基本不用

**（3）unique_ptr**

​		推荐使用

```C++
unique_ptr<int> p1(new int);
//unique_ptr<int> p2(p1);    //unique中拷贝构造是删除的，不能用拷贝构造
unique_ptr<int> p2(std::move(p1));   //通过 std::move 显式转移所有权
*p1;    //不能再解引用p1，move(p1)之后，p2指向p1之前的资源，p1的指针指向空
```

### 6.1.2 带计数器的智能指针

多个指针可以管理同一个资源

shared_ptr：强智能指针，可以改变资源的引用计数

weak_ptr：弱智能指针，不会改变资源的引用计数，只能观察资源，不能访问资源，可以提升为强智能指针

```C++
#include <iostream>
#include <memory>

class B; // 前向声明

class A {
public:
    std::shared_ptr<B> b_ptr; // A持有B的shared_ptr
    ~A() {std::cout << "A被销毁" << std::endl;}
};

class B {
public:
    std::shared_ptr<A> a_ptr; // B持有A的shared_ptr
    // std::weak_ptr<A> a_ptr; // 解决方法，修改为weak_ptr
    ~B() {std::cout << "B被销毁" << std::endl;}
};

int main() {
    {
        std::shared_ptr<A> a = std::make_shared<A>();   // 创建两个对象并相互引用
        std::shared_ptr<B> b = std::make_shared<B>();
        
        a->b_ptr = b; // A指向B
        b->a_ptr = a; // B指向A
    } // 离开作用域，预期会销毁a和b
    
    std::cout << "程序结束" << std::endl;
    return 0;
}
```

## 6.2 函数包装器function

`std::function` 是 C++11 引入的**通用多态函数包装器**（定义在 `<functional>` 头文件中），能存储、复制、调用各种 “可调用对象”（普通函数、Lambda、成员函数、仿函数等），让函数调用更灵活、类型更安全。`std::function` 是类模板，声明格式为：

```cpp
std::function<返回值类型(参数类型列表)> 变量名;
```

- 示例：`std::function<int(int, double)>` 表示 “接受 `int` 和 `double` 参数、返回 `int` 的可调用对象”。

### 6.2.1支持的可调用对象

**（1）包装普通函数**

普通函数的 “签名（返回值 + 参数）” 与 `std::function` 声明匹配时，可直接赋值。

```cpp
#include <iostream>
#include <functional>
using namespace std;

int add(int a, int b) {
    return a + b;
}

int main() {
    function<int(int, int)> func = add;
    cout << func(3, 5) << endl; // 输出：8
    return 0;
}
```

**（2）包装 Lambda 表达式**

Lambda 是匿名函数，可直接赋值给 `std::function`，适合快速定义临时逻辑。

```cpp
#include <iostream>
#include <functional>
#include <algorithm>
using namespace std;

int main() {
    int arr[] = {1, 5, 4, 8, 6};
    // Lambda 实现“降序比较”，赋值给 function
    function<bool(int, int)> cmp = [](int a, int b) { return a > b; };
    sort(arr, arr + 5, cmp);
    for (int num : arr) cout << num << " "; // 输出：8 6 5 4 1
    return 0;
}
```

**（3）包装成员函数**

成员函数隐含 `this` 指针，因此 `std::function` 的参数需包含 “类对象（指针 / 引用）”。

```cpp
#include <iostream>
#include <functional>
using namespace std;

class Foo {
public:
    Foo(int num) : num_(num) {}
    void printAdd(int i) const {
        cout << num_ + i << endl;
    }
private:
    int num_;
};

int main() {
    // 声明：返回值 void，参数为 const Foo& 和 int
    function<void(const Foo&, int)> f = &Foo::printAdd;
    Foo foo(2);
    f(foo, 3); // 调用 foo.printAdd(3)，输出：5
    return 0;
}
```

**（4）包装仿函数（函数对象）**

仿函数是**重载了 `operator()` 的类对象**，可像函数一样调用，也能被 `std::function` 包装。

```cpp
#include <iostream>
#include <functional>
using namespace std;

struct Adder {
    int operator()(int a, int b) const {
        return a + b;
    }
};

int main() {
    Adder adder;
    function<int(int, int)> func = adder;
    cout << func(2, 7) << endl; // 输出：9
    return 0;
}
```

## 6.3 绑定器bind

​	 `std::bind`（定义在 `<functional>` 头文件中）是一个灵活的**函数适配器**，可以将函数（或可调用对象）与部分 / 全部参数绑定，生成一个新的可调用对象。它解决了旧版 `bind1st`/`bind2nd` 只能绑定二元函数的局限，支持任意参数数量、调整参数顺序、绑定成员函数等场景。

### 6.3.1 基本用法

`std::bind` 的基本语法：

```cpp
auto 新对象 = std::bind(原函数, 参数列表);
```

- **参数列表**中，可用 `std::placeholders::_1, _2, ...` 表示 “待传入的参数”（占位符），其他值表示 “固定绑定的参数”。
- 调用 “新对象” 时，传入的参数会替换占位符，最终转发给原函数执行。

```cpp
#include <iostream>
#include <functional> // 包含 std::bind 和占位符
using namespace std;

// 1. 普通函数：计算 a + b * c
int calculate(int a, int b, int c) {
    return a + b * c;
}

// 2. 类与成员函数
class Math {
public:
    int multiply(int x, int y) { return x * y; } // 成员函数
    static int subtract(int x, int y) { return x - y; } // 静态成员函数
};

int main() {
    // 场景1：绑定普通函数，固定部分参数
    // 绑定 calculate 的第2个参数为 2，生成：a + 2 * c（需传入 a 和 c，对应 _1 和 _2）
    auto func1 = bind(calculate, placeholders::_1, 2, placeholders::_2);
    cout << "func1(3, 4) = " << func1(3, 4) << endl; // 3 + 2*4 = 11

    // 场景2：调整参数顺序
    // 绑定 calculate，将参数顺序改为 (c, a, b)，即 c + a * b（原参数 a,b,c）
    auto func2 = bind(calculate, placeholders::_2, placeholders::_3, placeholders::_1);
    cout << "func2(5, 1, 2) = " << func2(5, 1, 2) << endl; // 1 + 2*5 = 11（原 a=1, b=2, c=5）

    // 场景3：绑定成员函数（需传入对象指针/引用）
    Math m;
    // 绑定成员函数 multiply，固定第1个参数为 3（需传入对象和第2个参数 y）
    auto func3 = bind(&Math::multiply, &m, 3, placeholders::_1);
    cout << "func3(4) = " << func3(4) << endl; // 3 * 4 = 12

    // 场景4：绑定静态成员函数（无需对象，直接绑定）
    auto func4 = bind(&Math::subtract, placeholders::_2, placeholders::_1); // 交换参数
    cout << "func4(5, 8) = " << func4(5, 8) << endl; // 8 - 5 = 3

    return 0;
}
```

**总结**

`std::bind` 的核心价值在于**灵活适配函数参数**，主要特点：

1. **绑定任意参数**：支持固定部分参数，剩余参数用占位符接收（不限数量）。
2. **调整参数顺序**：通过占位符重新排列原函数的参数顺序。
3. **支持多种可调用对象**：普通函数、成员函数（需绑定对象）、静态成员函数、Lambda、仿函数等。

### 6.3.2 配合function使用

```C++
class Calculator {   // 定义一个简单的计算类
public:
    int compute(int a, int b, int c) {
        return a + b * c;
    }
    
    static int square(int x) {
        return x * x;
    }
};

int main() {
    Calculator calc;
    
    // 场景1：绑定成员函数，固定部分参数，用 function 存储
    // 绑定 compute 的第2个参数为 2，生成：a + 2 * c（需传入 a 和 c）
    function<int(int, int)> func1 = bind(
        &Calculator::compute,  // 成员函数地址
        &calc,                 // 绑定对象（this指针）
        placeholders::_1,      // 第一个占位符（对应 a）
        2,                     // 固定 b=2
        placeholders::_2       // 第二个占位符（对应 c）
    );
    
    // 场景2：绑定静态成员函数，调整参数顺序，用 function 存储
    // 静态函数无需绑定对象，这里演示用 bind 包装后存入 function
    function<int(int)> func2 = bind(&Calculator::square, placeholders::_1);
    
    // 场景3：绑定普通Lambda表达式，用 function 统一管理
    function<int(int, int)> func3 = bind(
        [](int x, int y) { return x * 10 + y; },  // Lambda表达式
        placeholders::_2,                         // 交换参数顺序：先 y 后 x
        placeholders::_1
    );
    
    // 调用包装后的函数
    cout << "func1(3, 4) = " << func1(3, 4) << endl;  // 3 + 2*4 = 11
    cout << "func2(5) = " << func2(5) << endl;        // 5*5 = 25
    cout << "func3(6, 7) = " << func3(6, 7) << endl;  // 7*10 + 6 = 76
    
    return 0;
}
```

**代码说明：**

1. **`std::bind` 的作用**：

   - 绑定成员函数时，需要指定对象指针（`&calc`）作为第一个参数（对应 `this` 指针）。
   - 通过 `placeholders::_1`、`_2` 等占位符预留参数位置，后续调用时传入的参数会替换这些占位符。
   - 支持调整参数顺序（如场景 3 中交换了 Lambda 的参数顺序）。

2. **`std::function` 的作用**：

   - 提供统一的类型接口，无论 `bind` 绑定的是成员函数、静态函数还是 Lambda，都能存储在同类型的 `function` 对象中。
   - 方便函数的传递、存储和调用（如作为函数参数或返回值）。

3. **结合优势**：

   两者配合使用，既能通过 `bind` 灵活调整函数参数（固定值、重排顺序），又能通过 `function` 实现可调用对象的类型安全管理，非常适合回调函数、策略模式等场景。

## 6.4 lambda表达式

lambda表达式是函数对象的升级版

lambda 表达式的完整结构如下：

```cpp
[capture-list] (parameter-list) mutable noexcept -> return-type { function-body }
//[捕获外部变量]（形参列表）mutable noexcept -> 返回值类型 {函数体}
```

各部分含义：

- **`[capture-list]`（捕获列表）**：指定从 lambda 所在作用域中 “捕获” 哪些变量（用于在 lambda 内部使用）。**（相当于对应的函数对象的构造函数接收的参数）**
- **`(parameter-list)`（参数列表）**：与普通函数的参数列表一致，可省略（无参数时）。（**相当于对应函数对象的运算符重载operator（）传入的参数）**
- **`mutable`（可选）**：允许修改按值捕获的变量（默认按值捕获的变量是 `const` 副本）。
- **`noexcept`（可选）**：声明 lambda 不会抛出异常。
- **`-> return-type`（返回类型，可选）**：指定返回值类型，若函数体只有 `return` 语句且类型可推导，可省略。（**相当于对应函数对象的运算符重载operator（）的返回值类型）**
- **`{ function-body }`（函数体）**：函数逻辑实现。（**相当于对应函数对象的运算符重载operator（）的函数体部分）**

| 捕获方式    | 含义                                                         |
| ----------- | ------------------------------------------------------------ |
| `[]`        | 不捕获任何外部变量（lambda 内部无法使用外部变量）。相当于对应的函数对象的构造函数不接收参数 |
| `[var]`     | 按**值**捕获变量 `var`（内部是副本，修改不影响外部）。       |
| `[&var]`    | 按**引用**捕获变量 `var`（内部是引用，修改会影响外部）。     |
| `[=]`       | 按**值**捕获**所有**外部变量（lambda 中使用的变量均为副本）。 |
| `[&]`       | 按**引用**捕获**所有**外部变量（lambda 中使用的变量均为引用）。 |
| `[=, &var]` | 除 `var` 按引用捕获外，其余变量按值捕获（`&var` 覆盖默认的 `=`）。 |
| `[&, var]`  | 除 `var` 按值捕获外，其余变量按引用捕获（`var` 覆盖默认的 `&`）。 |
| `[this]`    | 在类的成员函数中，捕获当前对象的 `this` 指针（可访问类的成员变量 / 函数）。 |

```cpp
#include <iostream>
using namespace std;

int main() {
    int a = 10, b = 20;

    // 1. [=]：按值捕获所有变量（a和b的副本）
    auto lambda1 = [=]() {
        cout << "lambda1: a=" << a << ", b=" << b << endl;  // 可访问a、b的副本
        // a++;  // 错误：按值捕获的变量默认是const，不能修改
    };

    // 2. [&]：按引用捕获所有变量（a和b的引用）
    auto lambda2 = [&]() {
        a++;  // 合法：修改的是外部a
        b++;  // 合法：修改的是外部b
        cout << "lambda2: a=" << a << ", b=" << b << endl;
    };

    // 3. [a, &b]：a按值捕获，b按引用捕获
    auto lambda3 = [a, &b]() mutable {  // mutable允许修改按值捕获的a
        a++;  // 仅修改副本，不影响外部a
        b++;  // 修改外部b
        cout << "lambda3: 副本a=" << a << ", 外部b=" << b << endl;
    };

    lambda1();  // 输出：lambda1: a=10, b=20
    lambda2();  // 输出：lambda2: a=11, b=21（外部a、b已被修改）
    lambda3();  // 输出：lambda3: 副本a=11, 外部b=22（外部b再次被修改）
    cout << "外部：a=" << a << ", b=" << b << endl;  // 输出：外部：a=11, b=22
    return 0;
}
```

**`mutable` 关键字的作用**

默认情况下，**按值捕获的变量在 lambda 内部是 `const` 副本**，无法修改。若需要修改按值捕获的变量，需用 `mutable` 修饰 lambda：

```cpp
int x = 5;
auto func = [x]() mutable {  // mutable 取消按值捕获变量的 const 限制
    x++;  // 合法：修改的是副本
    cout << "内部x=" << x << endl;  // 输出：6
};
func();
cout << "外部x=" << x << endl;  // 输出：5（外部变量不受影响）
```

**应用场景**

lambda 最适合**简短的、临时的函数逻辑**，常见场景：

（1）**作为算法的谓词**（如 `sort`、`find_if` 等 STL 算法）：

```cpp
#include <vector>
#include <algorithm>
vector<int> nums = {3, 1, 4, 1, 5};
// 用lambda指定排序规则（降序）
sort(nums.begin(), nums.end(), [](int a, int b) { return a > b; });
```

（2）**作为回调函数**（如线程任务、事件响应）：

```cpp
#include <thread>
// 用lambda作为线程任务
thread t([]() { cout << "线程执行中..." << endl; });
t.join();
```

（3）**简化代码**（替代简短的命名函数或仿函数）：

避免为仅使用一次的简单逻辑单独定义函数，使代码更紧凑。

## 6.5 多线程编程

生产者消费者模型

```cpp
#include<iostream>
#include<thread>
#include<mutex>
#include<queue>
#include<condition_variable>
using namespace std;

mutex mtx;
condition_variable cv;

class Queue {
public:
	void put(int val) {
		
		unique_lock<mutex> lck(mtx);
		while (!que.empty()) {
			
			cv.wait(lck);
		}
		que.push(val);
		cv.notify_all();
		cout << "生产者 生产了：" << val << "号物品" << endl;
	}

	int get() {
		unique_lock<mutex> lck(mtx);

		while (que.empty()) {
			cv.wait(lck);
		}
		
		int val = que.front();
		que.pop();
		cv.notify_all();
		cout << "消费者 消费了：" << val << "号物品" << endl;
		return val;
	}

private:
	queue<int> que;

};

void producer(Queue* que) {

	for (int i = 1; i <= 10; i++) {
	que->put(i);
	this_thread::sleep_for(chrono::milliseconds(100));
	}

}

void consumer(Queue* que) {
	for (int i = 1; i <= 10; i++) {
		que->get();
		this_thread::sleep_for(chrono::milliseconds(150));
	}
}

int main() {
	Queue que;
	thread t1(producer, &que);
	thread t2(consumer, &que);
	t1.join();
	t2.join();

}

```

## 6.6 设计模式

### 6.6.1 单例模式

​	单例模式是一种创建型设计模式，其核心目标是确保一个类在程序生命周期中**只存在一个实例**，并提供一个**全局访问点**供其他代码使用。在 C++ 中，单例模式主要分为**饿汉式**和**懒汉式**两种实现方式，两者的核心区别在于**实例初始化的时机**。

#### **（1）饿汉式单例**

饿汉式的特点是：**在程序启动时（类加载阶段）就完成实例的初始化**，无论后续是否会使用该实例。

**实现原理**

- 将类的构造函数、拷贝构造函数、赋值运算符声明为私有（或删除），禁止外部创建新实例或复制实例。

- 在类内部定义一个静态的私有实例对象（类加载时初始化）。

- 提供一个静态的公有方法，返回该唯一实例的引用或指针。

```cpp
class SingletonHungry {
private:
    SingletonHungry() {}      // 私有构造函数：禁止外部创建实例
    
    // 禁用拷贝构造和赋值运算符（C++11及以上）
    SingletonHungry(const SingletonHungry&) = delete;
    SingletonHungry& operator=(const SingletonHungry&) = delete;
    
    // 静态私有实例（程序启动时初始化）
    static SingletonHungry instance;

public:
    // 全局访问点：返回唯一实例
    static SingletonHungry& getInstance() {
        return instance;
    }
};

SingletonHungry SingletonHungry::instance;   // 类外初始化静态成员（饿汉式的核心：在main函数执行前完成初始化）
```

**优缺点**

- 优点：实现简单，无需考虑线程安全问题（初始化在程序启动时完成，此时无多线程竞争）。
- 缺点：
  - 资源浪费：如果实例从未被使用，初始化的资源（如内存）会被白白占用。
  - 无法处理依赖关系：如果实例初始化依赖其他动态数据（如配置文件读取结果），饿汉式无法满足（因为初始化时机过早）。

#### **（2）懒汉式单例**

懒汉式的特点是：**实例在第一次被使用时才初始化**，避免了不必要的资源浪费。

**实现原理**

- 同样将构造函数、拷贝构造、赋值运算符私有化（或删除）。

- 类内部定义一个静态的私有指针（或引用），初始化为`nullptr`。

- 提供静态公有方法 getInstance()，在方法内部判断实例是否已创建：若未创建，则初始化实例；若已创建，则直接返回实例。

​	**基础版（非线程安全）**

```cpp
class SingletonLazy {
private:
    
    SingletonLazy() {}   // 私有构造函数
    
    SingletonLazy(const SingletonLazy&) = delete;   // 禁用拷贝和赋值
    SingletonLazy& operator=(const SingletonLazy&) = delete;
    
    static SingletonLazy* instance;   // 静态私有指针（初始化为nullptr）

public:
    // 全局访问点：第一次调用时初始化
    static SingletonLazy* getInstance() {
        if (instance == nullptr) {
            instance = new SingletonLazy(); // 第一次使用时创建
        }
        return instance;
    }
};

SingletonLazy* SingletonLazy::instance = nullptr;   // 初始化为nullptr
```

**问题**：多线程环境下，多个线程可能同时进入`if (instance == nullptr)`，导致创建多个实例，破坏单例特性。

**线程安全版（双重检查锁定）**

为解决线程安全问题，需引入锁机制，同时通过 “双重检查” 减少锁的开销：

```cpp
#include <mutex>

class SingletonLazySafe {
private:
    SingletonLazySafe() {}
    SingletonLazySafe(const SingletonLazySafe&) = delete;
    SingletonLazySafe& operator=(const SingletonLazySafe&) = delete;
    
    static SingletonLazySafe* instance;
    static std::mutex mtx; // 互斥锁

public:
    static SingletonLazySafe* getInstance() {
        // 第一次检查：未加锁，快速判断（避免每次调用都加锁）
        if (instance == nullptr) {
            std::lock_guard<std::mutex> lock(mtx); // 加锁
            // 第二次检查：加锁后再次判断（防止多线程同时通过第一次检查）
            if (instance == nullptr) {
                instance = new SingletonLazySafe();
            }
        }
        return instance;
    }
};

// 初始化静态成员
SingletonLazySafe* SingletonLazySafe::instance = nullptr;
std::mutex SingletonLazySafe::mtx;
```

**简化版（C++11 局部静态变量）**

C++11 标准规定：**局部静态变量的初始化是线程安全的**（在第一次访问时初始化，且仅一次）。利用这一特性可简化实现：

```cpp
class SingletonLazySimpler {
private:
    SingletonLazySimpler() {}
    SingletonLazySimpler(const SingletonLazySimpler&) = delete;
    SingletonLazySimpler& operator=(const SingletonLazySimpler&) = delete;

public:
    // 局部静态变量：第一次调用时初始化，且线程安全（C++11及以上）
    static SingletonLazySimpler& getInstance() {
        static SingletonLazySimpler instance;
        return instance;
    }
};
```

这是目前推荐的懒汉式实现方式，兼顾线程安全和简洁性。

**优缺点**

- 优点：
  - 延迟初始化，避免资源浪费（实例仅在需要时创建）。
  - 可处理动态依赖（初始化代码可放在`getInstance()`中，使用运行时数据）。
- 缺点：
  - 基础版线程不安全，需额外处理（如加锁）。
  - 实现相对复杂（非 C++11 环境下）。

| 特性       | 饿汉式                     | 懒汉式                               |
| ---------- | -------------------------- | ------------------------------------ |
| 初始化时机 | 程序启动时（类加载阶段）   | 第一次调用`getInstance()`时          |
| 线程安全   | 天然安全（无多线程竞争）   | 需额外处理（C++11 局部静态变量除外） |
| 资源占用   | 可能浪费（未使用也初始化） | 按需分配（更高效）                   |
| 依赖处理   | 不支持动态依赖             | 支持动态依赖                         |
| 实现复杂度 | 简单                       | 较复杂（需考虑线程安全）             |

**适用场景**

- **饿汉式**：适合实例占用资源少、肯定会被使用的场景（如日志器、配置管理器）。
- **懒汉式**：适合实例占用资源多、可能不被使用的场景（如大型缓存、数据库连接池）。

​	单例模式的核心是 “唯一实例 + 全局访问”，但需谨慎使用（可能导致代码耦合性升高），实际开发中应根据需求选择合适的实现方式。

# 7、文件操作

| 操作分类       | 函数 / 运算符 / 模式       | 适用流类型                            | 核心参数 / 语法                                 | 详细用法说明                                                 | 特点与注意事项                                               |
| -------------- | -------------------------- | ------------------------------------- | ----------------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| **文件打开**   | 流对象构造函数             | ifstream/<br />ofstream/<br />fstream | `ifstream in("file.txt", 打开模式);`            | 创建流对象时直接打开文件，第一个参数为文件名（C 风格字符串或 C++ string），第二个参数为打开模式组合。 | 若打开失败，流对象状态会置为错误（可通过`fail()`判断）；无需单独调用`open()`。 |
| **文件打开**   | `open()` 成员函数          | ifstream/ofstream/fstream             | `in.open("file.txt", 打开模式);`                | 流对象创建后，通过`open()`打开文件，参数同构造函数。         | 可重复调用（需先`close()`已打开文件）；常用于需要动态指定文件名的场景。 |
| **打开模式**   | `ios::in`                  | 所有输入相关流                        | 作为`open()`或构造函数的第二个参数              | 以 “读” 模式打开文件（文件必须存在，否则打开失败）。         | 是`ifstream`的默认模式（不指定时默认此模式）。               |
| **打开模式**   | `ios::out`                 | 所有输出相关流                        | 同上                                            | 以 “写” 模式打开文件（文件不存在则创建，存在则清空原有内容）。 | 是`ofstream`的默认模式；单独使用时隐含`ios::trunc`（截断）。 |
| **打开模式**   | `ios::app`                 | 输出流 / 双向流                       | 同上                                            | 以 “追加” 模式打开文件（写入数据会附加到文件末尾，原有内容保留）。 | 此时无法修改文件已有内容，只能在末尾添加；`seekp()`定位可能失效。 |
| **打开模式**   | `ios::ate`                 | 所有流                                | 同上                                            | 打开文件后，文件指针直接定位到文件末尾（可通过`seekg()`/`seekp()`移动）。 | 不影响读写方式，仅改变初始位置；可与`ios::in`/`ios::out`组合。 |
| **打开模式**   | `ios::trunc`               | 输出流 / 双向流                       | 同上                                            | 打开文件时清空原有内容（仅在文件存在时有效）。               | 与`ios::out`组合时默认生效；若需保留内容，需显式指定`ios::app`或`ios::in`。 |
| **文件关闭**   | `close()` 成员函数         | 所有流                                | `in.close();`                                   | 关闭文件，释放系统资源（流对象可重新用于打开其他文件）。     | 程序结束时会自动关闭，但显式调用更安全（尤其是需要立即保存数据时）。 |
| **读取操作**   | `>>` 提取运算符            | 输入流 / 双向流                       | `in >> 变量;`                                   | 从文件读取格式化数据（如 int、string、double 等），自动跳过空白字符（空格、换行、制表符）。 | 无法读取含空格的完整行；读取失败时流状态置为错误（可通过`fail()`判断）。 |
| **读取操作**   | `get()` 成员函数（单字符） | 输入流 / 双向流                       | `char c; in.get(c);` 或 `int c = in.get();`     | 读取单个字符（包括空白字符），前者通过引用返回，后者返回字符 ASCII 值（失败返回`EOF`）。 | 可读取换行符；若文件已到末尾，返回`EOF`（需用`int`接收判断）。 |
| **读取操作**   | `get()` 成员函数（缓冲区） | 输入流 / 双向流                       | `char buf[100]; in.get(buf, 100, '\n');`        | 读取最多 n-1 个字符到缓冲区，直到遇到分隔符（默认 '\n'）或达到长度上限，分隔符会留在输入流中。 | 缓冲区需预留结束符 '\0' 的空间；分隔符未被读取，下次读取会从分隔符开始。 |
| **读取操作**   | 全局`getline()`函数        | 输入流 / 双向流                       | `string s; getline(in, s, '\n');`               | 读取一整行文本到 string 对象，直到遇到分隔符（默认 '\n'），分隔符会被丢弃（不保留在流中）。 | 可读取含空格的完整行；若上一次读取残留分隔符，需先清空（如用`in.ignore()`）。 |
| **读取操作**   | 成员`getline()`函数        | 输入流 / 双向流                       | `char buf[100]; in.getline(buf, 100, '\n');`    | 功能同全局`getline()`，但目标是字符数组，需指定缓冲区大小。  | 超过缓冲区大小时会设置失败状态；需手动管理缓冲区大小，避免溢出。 |
| **写入操作**   | `<<` 插入运算符            | 输出流 / 双向流                       | `out << "内容" << 变量;`                        | 向文件写入格式化数据（如字符串、数字等），自动处理数据类型转换。 | 会将数据连续写入，需手动添加分隔符（如`\n`）；依赖缓冲区，不一定立即写入磁盘。 |
| **写入操作**   | `put()` 成员函数           | 输出流 / 双向流                       | `out.put('A');`                                 | 向文件写入单个字符（参数为 char 类型或 ASCII 值）。          | 适合单个字符写入；返回流对象本身，支持链式调用（如`out.put('a').put('b')`）。 |
| **写入操作**   | `write()` 成员函数         | 输出流 / 双向流                       | `const char* buf = "hello"; out.write(buf, 5);` | 向文件写入指定长度的字节序列（以字符指针和长度为参数）。     | 原用于二进制文件，但文本文件也可使用；需确保长度正确，否则可能写入垃圾数据。 |
| **状态检查**   | `eof()` 成员函数           | 所有流                                | `if (in.eof()) { ... }`                         | 判断是否已到达文件末尾（返回`true`表示已读完）。             | 仅在尝试读取并失败后才会置为`true`，不能提前判断 “下一个是否为结尾”。 |
| **状态检查**   | `fail()` 成员函数          | 所有流                                | `if (in.fail()) { ... }`                        | 判断是否发生可恢复错误（如打开不存在的文件、读取类型不匹配）。 | 错误可通过`clear()`清除，恢复流操作。                        |
| **状态检查**   | `good()` 成员函数          | 所有流                                | `if (in.good()) { ... }`                        | 判断流状态是否正常（无错误、未到末尾）。                     | 等价于`!fail() && !eof()`，是最全面的状态检查。              |
| **缓冲区操作** | `flush()` 成员函数         | 输出流 / 双向流                       | `out.flush();`                                  | 强制刷新输出缓冲区，将缓冲数据立即写入文件（不等待缓冲区满）。 | 常用于需要即时保存数据的场景（如日志记录）；`endl`会自动调用`flush()`。 |
| **指针操作**   | `seekg()` 成员函数         | 输入流 / 双向流                       | `in.seekg(10, ios::beg);`                       | 移动读指针到指定位置（第一个参数为偏移量，第二个参数为基准：`beg`开头、`cur`当前、`end`末尾）。 | 文本文件中慎用（换行符在不同系统中表示不同，可能导致定位不准）。 |
| **指针操作**   | `seekp()` 成员函数         | 输出流 / 双向流                       | `out.seekp(-5, ios::end);`                      | 移动写指针到指定位置，参数同`seekg()`。                      | 若文件以`ios::app`模式打开，此函数可能失效（始终追加到末尾）。 |

写文件：把内存中的数据转移到磁盘文件中；读文件：把磁盘文件中的数据转移到内存中

文本文件存放的是字符串，以行的方式组织数据

以文本方式读取文件的时候，遇到换行符停止，读入的内容中没有换行符；以二进制方式读取文件的时候，遇到换行符不会停止，读入的内容中包含换行符（换行符被视为数据）





# 问题整理

## 一、基础知识

### 1、C++为什么区分单个元素和数组的内存分配和释放？

- 对于普通的编译器内置类型  new/delete[]    new[]/delete  是可以混用的

- 对于自定义的类类型，有析构函数，为了调用正确的析构函数，那么开辟对象数组的时候，会额外开辟4个字节，用来记录对象的个数

  ```C++
  #include <iostream>
  using namespace std;
  
  class Test {
  private:
      int id; 
  public:
      Test(int id) : id(id) {
          cout << "Test(" << id << ") 构造函数被调用" << endl;
      }
  
      ~Test() {
          cout << "~Test(" << id << ") 析构函数被调用" << endl;
      }
  };
  
  int main() {
      // 情况1：正确使用 new[] 创建数组，delete[] 释放（匹配）
      cout << "=== 正确用法：new[] + delete[] ===" << endl;
      Test* arr = new Test[3]{1, 2, 3}; // 创建3个对象的数组
      delete[] arr; // 释放数组
      cout << endl;
  
      // 情况2：错误用法：new[] 创建数组，却用 delete 释放（不匹配）
      cout << "=== 错误用法：new[] + delete ===" << endl;
      Test* arr2 = new Test[3]{4, 5, 6};
      delete arr2; // 错误：用单个delete释放数组
      cout << endl;
  
      // 情况3：错误用法：new 创建单个对象，却用 delete[] 释放（不匹配）
      cout << "=== 错误用法：new + delete[] ===" << endl;
      Test* single = new Test(7); // 创建单个对象
      delete[] single; // 错误：用delete[]释放单个对象
      cout << endl;
  
      return 0;
  }
  ```

  ### 关键原理分析

  （1）**自定义类的 `new[]` 操作**：

  当用 `new[]` 创建对象数组时（如 `new Test[3]`），编译器会：

  - 额外分配 **4 字节（或平台对齐的字节数）** 用于存储 “对象个数”（这里是 3）。
  - 依次调用每个对象的构造函数（3 次）。

  内存布局大致为：

  <img src="assets/内存布局.png" alt="内存布局" style="zoom:50%;" />

（2）**`delete[]` 的工作逻辑**：

释放数组时，`delete[]` 会：

- 先读取开头的 “4 字节个数”（3），依次调用每个对象的析构函数（3 次）。
- 再释放包括 “4 字节个数” 在内的整块内存。

（3）**不匹配使用的问题**：

- **`new[] + delete`**：`delete` 不知道 “4 字节个数” 的存在，只会调用**1 次析构函数**（通常是第一个对象），导致剩余对象未析构（内存泄漏，若对象持有资源如堆内存，会导致严重问题）。
- **`new + delete[]`**：`delete[]` 会试图读取 “4 字节个数”，但 `new` 创建的单个对象没有这部分数据，会读取到**随机垃圾值**，导致析构函数被调用 “随机次数”（可能崩溃）。

（4）**内置类型为什么可以混用？**

内置类型（如 `int`、`double`）没有析构函数，`new[]` 不需要额外存储 “个数”（或存储了也无需使用）。`delete` 和 `delete[]` 此时仅需释放内存，不会涉及析构函数调用，因此看似可以混用（但仍不推荐，不符合规范）。

### 2、堆内存和栈内存的区别

| 对比维度       | 栈（Stack）                                | 堆（Heap）                                    |
| -------------- | ------------------------------------------ | --------------------------------------------- |
| **管理方式**   | 编译器**自动管理**，无需手动干预           | 程序员**手动管理**（或垃圾回收机制辅助）      |
| **分配与释放** | 函数调用时自动分配栈帧，函数结束时自动释放 | 运行时手动`new/malloc`申请，`delete/free`释放 |
| **空间大小**   | 通常较小（几 MB~ 几百 MB），易栈溢出       | 受系统内存限制，远大于栈（可达 GB 级）        |
| **访问速度**   | 内存连续，CPU 缓存友好，速度**更快**       | 内存非连续，需指针解引用，速度**稍慢**        |
| **生命周期**   | 与函数调用绑定，函数结束后自动销毁         | 由程序员控制，可跨函数 / 程序生命周期         |
| **存储内容**   | 局部变量、函数参数、返回地址等临时信息     | 动态对象、动态数组、生命周期长的数据          |
| **内存碎片**   | 几乎无碎片（连续分配 + 自动释放）          | 频繁分配 / 释放易产生碎片                     |
| **生长方向**   | 高地址 → 低地址                            | 低地址 → 高地址                               |

静态创建：在栈内存中分配         动态创建：在堆内存中分配







## 二、C++基础部分

### 1、new和malloc有什么区别？

- malloc和free是库函数，new和delete是运算符
- malloc是按字节开辟内存的，所以malloc开辟的内存都是void*；new开辟内存时需要指定类型
- malloc只开辟内存，而new不仅可以开辟内存，同时还可以做初始化的操作
- malloc开辟内存失败是通过返回值和nullptr做比较；而new开辟内存失败是通过抛出bad_alloc类型的异常来判断
  **注意：**C++代码里面尽量不用malloc和free

### 2、为什么函数调用的参数要从右往左压栈？



## 三、面向对象

### 1、为什么子类对象的地址可以被父类指针接受？

这是C++中多态的核心机制之一，向上转型，本质是父类指针/引用可以安全地指向子类对象，因为子类包含了父类的所有成员。

比如：“狗”是“动物”的子类，那么狗的对象自然也可以被视为动物。

### 2、派生类对象构造和析构的顺序

构造：基类构造函数→初始化基类成员变量→派生类构造函数→派生类成员变量

析构：派生类析构→基类析构

### 3、什么时候把基类的析构函数必须实现成虚函数（虚析构）

​	基类指针（引用）指向堆上new出来的派生类对象的时候，且通过该指针 / 引用调用 `delete` 释放对象时，基类的析构函数必须定义为虚函数。**基类的析构函数是虚函数，那么派生类的析构函数自动成为虚函数。**

```C++
#include <iostream>
#include <cstring>
using namespace std;

// 基类：析构函数非虚
class Base {
public:
    Base() {}

    // 非虚析构函数（错误：若用基类指针管理派生类对象，会导致泄漏）
    ~Base() {       // 这里必须写成 virtual ~Base()
        cout << "Base 析构函数：释放基类资源" << endl;
    }
};

class Derived : public Base {   // 派生类：包含动态分配的资源（char* 数组）
private:
    char* buffer; // 动态内存：需在析构中释放

public:
    Derived(const char* str) {
        buffer = new char[strlen(str) + 1]; 
        strcpy(buffer, str);                
    }

    ~Derived() override {              // 派生类析构函数：需释放动态内存
        delete[] buffer; // 释放动态内存
    }
};

int main() {
    Base* ptr = new Derived("Hello Derived"); 
    delete ptr;    // 错误：delete 基类指针，仅调用 Base 析构，Derived 的 buffer 未释放（内存泄漏）
    return 0;
}
```

### 4、怎么避免多继承问题

**（1）优先使用 “单继承 + 组合” 替代多继承**

​		多继承的核心问题是会增加类之间的耦合性和复杂度，而 “组合”（Has-a 关系）比 “继承”（Is-a 关系）更灵活，能有效避免继承链的混乱。

**（2）限制多继承为 “接口继承”（纯虚函数类）**

​		如果必须使用多继承，应仅继承**纯虚函数接口**（不含成员变量和实现的类），避免继承 “带实现的类”。因为纯虚接口没有数据和实现，不会导致数据冗余或冲突。

**（3）通过 “虚继承” 解决菱形继承问题**

若不可避免需要继承多个带实现的类，且存在 “菱形继承”（多个派生类继承自同一基类，最终又被一个类多继承），可使用**虚继承**消除基类的多份副本。

### 5、析构函数可以被重载吗？

在 C++ 中，**析构函数不能被重载**。

原因如下：

1. **析构函数的特殊语法**：析构函数的名字是固定的（类名前加`~`），且**没有参数**，也**没有返回值类型**。
2. **重载的前提不满足**：函数重载要求多个函数具有相同的名字，但**参数列表（参数个数、类型或顺序）不同**。由于析构函数没有参数，无法通过参数列表区分不同的析构函数，因此无法重载。
3. **语言规定**：C++ 标准明确规定，每个类**只能有一个析构函数**。如果尝试定义多个析构函数，编译器会报错。

对比：与析构函数不同，**构造函数可以被重载**，因为构造函数可以有不同的参数列表（例如默认构造函数、带参数的构造函数等），满足重载的条件。

### 6、什么函数不能被继承？

构造函数、析构函数、友元函数、拷贝构造函数、拷贝赋值函数、移动构造函数、移动赋值函数







## 四、模板



## 五、STL







## 六、C++11特性



### 1、强智能指针的循环引用（交叉引用），会造成什么结果？怎样解决？

会使得new出来的资源无法释放，造成资源泄露的问题。

解决方法：定义对象时，用强智能指针，引用对象时，用弱智能指针

### 2、多线程访问共享对象的线程安全问题

可以使用智能指针来解决





# git工作流程

## （1）一些git命令

- git clone ssh地址，将远程仓库代码拉取到本地

- git add . ，把git工作区的代码改动添加到暂存区

- git commit -m "备注"，把暂存区的代码提交到本地分支

- git push origin main，将本地仓库代码更新到远程origin/main仓库

- git pull，把远程代码拉取到本地

- git status，查看当前操作的状态信息

- git log，查看代码修改日志

- git branch 分支名     创建分支

- git checkout 分支名   切换分支

- git branch -a  查看所有分支

- 

- git checkout -- <file> 在git add之前，把工作区的代码用版本库中的代码覆盖掉，注意命令中的--不能去掉，否则成切换分支的命令了

- git reset HEAD 把git add之后，暂存区的内容全部撤销

- git reset --hard commit-id  把提交到本地仓库中的代码改动进行回退

- git reflog 查看HEAD指针的改动日志

- git push -f origin main 强制推送本地仓库代码到远程仓库

- git diff HEAD -- <file> 查看工作区file文件和仓库中该文件最新版本的 代码有什么区别

![git撤销](assets/git撤销.png)

## （2）名词介绍

- 工作区：当前存放项目代码的目录
- 暂存区：git add把工作区修改的内容添加到暂存区当中
- 本地仓库：git commit 把本地暂存区的修改提交到本地代码仓库分支中（不同分支代表不同的代码版本）
- 远程仓库：通过git push 把本地仓科的某一分支上的代码推送到远程仓库的某个分支上
- HEAD指针：本地仓库每一个分支上的代码修改都会生成一个commit id 信息，HEAD指针指向最近一次的commit提交，通过这个commit id 可以进行版本回退



cl 文件名 /d1reportSingleClassLayoutB                         B是类名

# 经典题目

## 一、基础知识





## 二、C++基础部分

## 三、面向对象

## 四、模板

## 五、STL

## 六、C++11新特性



# 实习校招

## 实习

| 公司                         | 地点 | 岗位                     | 要求技术栈                                                   |
| ---------------------------- | ---- | ------------------------ | ------------------------------------------------------------ |
| 浙江中控信息产业股份有限公司 | 杭州 | C++开发                  | 熟悉ubantu、QT、网络编程及其协议（TCP/IP、UDP、HTTP）        |
| 苏州易德龙科技股份有限公司   | 苏州 | 商业及数字化创新部实习生 | 本科及以上，电子/计算机/自动化等相关专业毕业；<br/>硕士研究方向为目标检测、图像处理等相关方向工作； |
|                              |      |                          |                                                              |
|                              |      |                          |                                                              |

## 校招

| 公司                               | 地点 | 岗位                 | 薪资   | 技术栈                                                       |
| ---------------------------------- | ---- | -------------------- | ------ | ------------------------------------------------------------ |
| 浙江中控信息产业股份有限公司       | 杭州 | C++开发              |        | 熟练掌握C/C++及数据结构，熟练掌握网络编程、多线程编程；<br />熟悉掌握数据库编程，至少熟悉mysql、oracle等至少一种数据库 |
| 立讯工业                           | 苏州 | 软件开发工程师       |        | 熟练掌握C/C++，熟悉x86、ARM/RISC -V CPU架构和PCle、RDMA、Ethernet等协议 |
| 南京博涯信息技术有限公司           | 南京 | C++开发工程师        |        | 掌握高性能编程技术：无锁数据结构、内存池优化；熟悉Linux系统编程，精通多线程、网络编程（TCP/UDP Multicast）；熟悉常用性能分析工具：perf、Valgrind、GDB |
| 南京巨鲨显示科技有限公司           | 南京 | 嵌入式软件工程师     | 30w    | C/C++开发、QT应用开发经验，熟悉面向对象编程。<br/>熟悉QT应用开发框架；熟悉在Linux平台进行QT开发工作，熟悉多线程开发；熟悉基本的QT组件，能够进行自绘组件的开发；<br/>熟悉Sqlite等本地数据库；熟悉网络通信，modbus通信。 |
| 扬州宇安电子科技股份有限公司       | 扬州 | C++工程师            | 15w    | 具有 window/Linux 平台 C/C++相关经验；<br/>精通 C/C++语言编程，精通基本的多线程、异步技术；<br/>熟练使用 MFC、QT、Socket、TCP\IP； |
| 嘉兴海拉灯具有限公司南京研发分公司 | 南京 | 软件工程师           | 20w    | 熟练使用C/C++开发语言 / Familiar with C/C++<br/>具有嵌入式软件开发项目经验, 了解单片机原理 |
| 英诺激光科技股份有限公司           | 深圳 | 软件工程师           | 18w    | 熟练使用C++或C#编程语言，具有良好的编程基础；<br/>熟悉机器视觉系统，具备图像处理的基础理论，熟练VisionPro、Halcon，opencv其中至少一种图像处理算法库； |
| 睿联技术                           | 深圳 | 嵌入式软件开发工程师 | 18k/月 | 计算机基础理论知识扎实，熟练使用C或者C++；                   |
| 傲拓科技股份有限公司               | 南京 | 上位机软件工程师     | 20w    | 具备上位机软件开发的项目经验，熟悉C/C++语言，熟悉面向对象设计和编程，有良好的代码编写风格；<br/>熟悉QT编程，了解QT底层原理；<br/>了解多进程、多线程并发环境编程，以及进程间通信的实现方式； |
|                                    |      | 嵌入式软件开发工程师 | 21w    | 具备嵌入式软件开发的项目经验，熟悉C/C++语言程序设计，了解编译原理，有良好的代码编写风格；<br/>了解Linux或其他嵌入式实时操作系统，有良好的数据结构基础，了解计算机网络通讯及现场总线如工业以太网或CAN总线；<br/>熟悉16/32位MCU，熟悉ARM或MIPS平台处理器； |
| 智翼博智能科技（苏州）有限公司     | 苏州 | 软件算法工程师       | 12W    | 希望在机器视觉行业深耕，愿意学习新技术、新技能；<br/>熟悉C#、Halcon、VisionPro或OpenCV优先；<br/>能接受短期，不定时出差。 |
| 万帮数字能源股份有限公司           | 常州 | 嵌入式软件工程师     | 30w    | 熟练掌握C/C++语言编程；<br/>了解ARM/STM32等芯片开发，有Cortex-A核开发经验优先；<br/>具备良好的硬件基础，能阅读原理图，使用信号分析仪等调试工具； |
| 吴江华丰电子科技有限公司           | 苏州 | 软件工程师           | 18w    | 熟练使用C# ,C,C++,Python等任何一门语言；<br/>具有较强的学习能力，能够学习C#语言做上位机开发，自动化软件开发等工作； |
| 南京烽火星空通信发展有限公司       | 南京 | 软件工程师           | 12w    | 熟练掌握C/C++编程语言、语法，掌握Linux、Shell脚本，掌握系统编程（IO、多线程、网络编程、内存管理）；熟练掌握关系型数据库及相关工具，例如MySQL、Oracle、PostgreSQL、Gbase等；掌握常用的数据结构（链表、树、图、哈希表、队列、栈等）、算法（排序、查找等）、标准库和STL；<br/>了解进程、线程、同步互斥、文件系统、虚拟内存等概念，理解缓冲区溢出、空指针、野指针；<br/>熟练使用G++/GCC编译器、了解常用设计模式、对软件工程有一定理解。 |
| 江苏金陵科技集团有限公司           | 南京 | c++研发工程师        | 20W    | 精通C/C++，熟悉Linux系统下的软件开发； 精通网络编程，熟悉TCP、IP协议栈； 熟悉Linux操作系统，熟练使用常见Linux命令； |







